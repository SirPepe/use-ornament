<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Ornament | Build your own frontend framework</title><meta name="viewport" content="width=device-width"><meta name="description" content="A framework for web component frameworks"><meta name="fediverse:creator" content="@sirpepe@mastodon.social"><link rel="icon" href="favicon.cf6055ad.svg" type="image/svg+xml"><script type="module" src="use-ornament.8170d3fb.js"></script><link rel="stylesheet" href="use-ornament.b235105c.css"></head><body> <div class="wrapper"> <header> <h1>A framework for <mark>web component frameworks</mark></h1> <p><code>npm i <a href="https://www.npmjs.com/package/@sirpepe/ornament">@sirpepe/ornament</a></code></p> </header> <main><p>ðŸ“¢ <strong>What&#39;s new in 3.0.1?</strong> <a href="https://github.com/SirPepe/ornament/blob/main/changelog.md">Check out the Changelog!</a></p> <p><strong>Build your own frontend framework</strong> with Ornament, a stable, mid-level, pareto-optimal, treeshakable and tiny TypeScript-positive toolkit for web component infrastructure! Escape from heavyweight frameworks, constant rewrites and the all-encompassing frontend FOMO with a declarative, simple, and type-safe API for web components:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> {
  define,
  attr,
  string,
  number,
  connected,
  reactive,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// Register the element with the specified tag name</span>
@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-greeter&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyGreeter</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// No built-in rendering functionality. Shadow DOM or light DOM? Template</span>
  <span class="hljs-comment">// strings, JSX, or something else entirely? You decide!</span>
  #shadow = <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });

  <span class="hljs-comment">// Define content attributes alongside corresponding getter/setter pairs</span>
  <span class="hljs-comment">// for a JS api and attribute change handling and type checking. If you use</span>
  <span class="hljs-comment">// TypeScript, the type checks will work at compile time *and* at run time</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>()) accessor name = <span class="hljs-string">&quot;Anonymous&quot;</span>;
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span> })) accessor age = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// Mark the method as reactive to have it run every time one of the attributes</span>
  <span class="hljs-comment">// change, and also run it when the component first connects to the DOM.</span>
  @<span class="function_ hljs-title">reactive</span>()
  @<span class="function_ hljs-title">connected</span>()
  <span class="function_ hljs-title">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.#shadow.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`Hello! My name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>, my age is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.age}</span>`</span>;
  }
}
</code></pre><p>Ornament makes quasi-vanilla web components fun and easy when compared to the equivalent boilerplate monstrosity that one would have to write by hand otherwise:</p> <details> <summary>ðŸ˜± Unveil the horror ðŸ˜±</summary> <pre><code class="hljs language-javascript"><span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyGreeter</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  #shadow = <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });

  <span class="hljs-comment">// Internal &quot;name&quot; and &quot;age&quot; states, initialized from the element&#x27;s content</span>
  <span class="hljs-comment">// attributes, with default values in case the content attributes are not set.</span>
  <span class="hljs-comment">// The value for &quot;age&quot; has to be figured out with some imperative code in the</span>
  <span class="hljs-comment">// constructor to keep NaN off our backs.</span>
  #name = <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">getAttribute</span>(<span class="hljs-string">&quot;name&quot;</span>) || <span class="hljs-string">&quot;Anonymous&quot;</span>;
  #age;

  <span class="function_ hljs-title">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>(); <span class="hljs-comment">// mandatory boilerplate</span>
    <span class="hljs-keyword">let</span> age = <span class="class_ hljs-title">Number</span>(<span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">getAttribute</span>(<span class="hljs-string">&quot;age&quot;</span>));
    <span class="hljs-keyword">if</span> (<span class="class_ hljs-title">Number</span>.<span class="hljs-built_in">isNaN</span>(age)) {
      <span class="hljs-comment">// Remember to keep NaN in check</span>
      age = <span class="hljs-number">0</span>;
    }
    <span class="hljs-variable language_">this</span>.#age = <span class="hljs-number">0</span>;
  }

  <span class="hljs-comment">// Remember to run the reactive method when connecting to the DOM</span>
  <span class="function_ hljs-title">connectedCallback</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">greet</span>();
  }

  <span class="hljs-comment">// Method to run each time `#name` or `#age` changes</span>
  <span class="function_ hljs-title">greet</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.#shadow.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`Hello! My name is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#name}</span>, my age is <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#age}</span>`</span>;
  }

  <span class="hljs-comment">// DOM getter for the IDL attribute, required to make JS operations like</span>
  <span class="hljs-comment">// `console.log(el.name)` work</span>
  <span class="hljs-keyword">get</span> <span class="function_ hljs-title">name</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;
  }

  <span class="hljs-comment">// DOM setter for the IDL attribute with type checking and/or conversion *and*</span>
  <span class="hljs-comment">// attribute updates, required to make JS operations like `el.name = &quot;Alice&quot;`</span>
  <span class="hljs-comment">// work.</span>
  <span class="hljs-keyword">set</span> <span class="function_ hljs-title">name</span>(<span class="hljs-params">value</span>) {
    value = <span class="class_ hljs-title">String</span>(value); <span class="hljs-comment">// Remember to convert/check the type!</span>
    <span class="hljs-variable language_">this</span>.#name = value;
    <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">setAttribute</span>(<span class="hljs-string">&quot;name&quot;</span>, value); <span class="hljs-comment">// Remember to sync the content attribute!</span>
    <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">greet</span>(); <span class="hljs-comment">// Remember to run the method!</span>
  }

  <span class="hljs-comment">// DOM getter for the IDL attribute, required to make JS operations like</span>
  <span class="hljs-comment">// `console.log(el.age)` work</span>
  <span class="hljs-keyword">get</span> <span class="function_ hljs-title">age</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#age;
  }

  <span class="hljs-comment">// DOM setter for the IDL attribute with type checking and/or conversion *and*</span>
  <span class="hljs-comment">// attribute updates, required to make JS operations like `el.age = 42` work.</span>
  <span class="hljs-keyword">set</span> <span class="function_ hljs-title">age</span>(<span class="hljs-params">value</span>) {
    value = <span class="class_ hljs-title">Number</span>(value); <span class="hljs-comment">// Remember to convert/check the type!</span>
    <span class="hljs-keyword">if</span> (<span class="class_ hljs-title">Number</span>.<span class="hljs-built_in">isNaN</span>(value) || value &lt; <span class="hljs-number">0</span>) {
      <span class="hljs-comment">// Remember to keep NaN in check</span>
      value = <span class="hljs-number">0</span>;
    }
    <span class="hljs-variable language_">this</span>.#age = value;
    <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">setAttribute</span>(<span class="hljs-string">&quot;age&quot;</span>, value); <span class="hljs-comment">// Remember to sync the content attribute!</span>
    <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">greet</span>(); <span class="hljs-comment">// Remember to run the method!</span>
  }

  <span class="hljs-comment">// Attribute change handling, required to make JS operations like</span>
  <span class="hljs-comment">// `el.setAttribute(&quot;name&quot;, &quot;Bob&quot;)` update the internal element state.</span>
  <span class="function_ hljs-title">attributeChangedCallback</span>(<span class="hljs-params">name, oldValue, newValue</span>) {
    <span class="hljs-comment">// Because `#name` is a string, and attribute values are always strings as</span>
    <span class="hljs-comment">// well we don&#x27;t need to convert the types at this stage, but we still need</span>
    <span class="hljs-comment">// to manually make sure that we fall back to &quot;Anonymous&quot; if the new value</span>
    <span class="hljs-comment">// is null (if the attribute got removed) or if the value is (essentially)</span>
    <span class="hljs-comment">// an empty string</span>
    <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&quot;name&quot;</span>) {
      <span class="hljs-keyword">if</span> (newValue === <span class="hljs-literal">null</span> || newValue.<span class="function_ hljs-title">trim</span>() === <span class="hljs-string">&quot;&quot;</span>) {
        newValue = <span class="hljs-string">&quot;Anonymous&quot;</span>;
      }
      <span class="hljs-variable language_">this</span>.#name = newValue;
      <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">greet</span>(); <span class="hljs-comment">// Remember to run the method!</span>
    }
    <span class="hljs-comment">// But for &quot;#age&quot; we do again need to convert types, check for NaN, enforce</span>
    <span class="hljs-comment">// the min value of 0...</span>
    <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&quot;age&quot;</span>) {
      <span class="hljs-keyword">const</span> value = <span class="class_ hljs-title">Number</span>(value); <span class="hljs-comment">// Remember to convert/check the type!</span>
      <span class="hljs-keyword">if</span> (<span class="class_ hljs-title">Number</span>.<span class="hljs-built_in">isNaN</span>(value) || value &lt; <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// Remember to keep NaN in check</span>
        value = <span class="hljs-number">0</span>;
      }
      <span class="hljs-variable language_">this</span>.#age = value;
      <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">greet</span>(); <span class="hljs-comment">// Remember to run the method!</span>
    }
  }

  <span class="hljs-comment">// Required for attribute change monitoring to work</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">get</span> <span class="function_ hljs-title">observedAttributes</span>() {
    <span class="hljs-keyword">return</span> [<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>]; <span class="hljs-comment">// remember to always keep this up to date</span>
  }
}

<span class="hljs-comment">// Finally remember to register the element</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-greeter&quot;</span>, <span class="class_ hljs-title">MyGreeter</span>);
</code></pre></details> <p>Ornament makes <em>only the most tedious bits</em> of building vanilla web components (attribute handling and lifecycle reactions) easy by adding some primitives that really should be part of the standard, but aren&#39;t. <strong>Ornament is not a framework,</strong> but something that you want to build your own framework on top of. Combine Ornament&#39;s baseline web component features with something like <a href="https://github.com/WebReflection/uhtml">uhtml</a> or <a href="https://preactjs.com/">Preact</a> for rending, add your favorite state management library, write some glue code and enjoy your very own frontend web framework.</p> <aside> <h2>About the author</h2> <img src="peter.77e23c2e.jpg" alt> <div> <p> Hi, I'm Peter! I made Ornament and do workshops, code reviews and consulting on core web technologies as a freelancer. <strong><mark>Hire me</mark></strong> to level up your colleagues, review your TypeScript, or to solve your web component issues! </p> <p> <a href="mailto:peter@peterkroener.de">Contact me via email</a>, follow me <a rel="me" href="https://mastodon.social/@sir_pepe">on Mastodon</a> or <a href="https://github.com/SirPepe/">on GitHub</a>, and check out <a href="https://code.movie/">Code.Movie</a> for something <em>entirely</em> different! </p> </div> </aside> <h2 id="tutorial">Tutorial: click counter with Preact</h2> <p> Step through this tutorial to see how a component built with <a href="https://preactjs.com/">Preact</a> comes together, but note that you don't have to use Preact with Ornament! You can use tagged template literals, vanilla DOM manipulation, state could live in Signals&nbsp;&hellip; it's up to you! </p> <div class="tutorial"> <code-movie-runtime keyframes="0 1 2 3 4 5 6 7 8 9 10 11"><div class="cm-animation cwxqmrv frame11"> <div class="s"> <span class="iw ix">1</span><span class="iw iy">2</span><span class="iw iz">3</span><span class="iw ja">4</span><span class="iw jb">5</span><span class="iw jc">6</span><span class="iw jd">7</span><span class="iw je">8</span><span class="iw jf">9</span><span class="iw jg">10</span><span class="iw jh">11</span><span class="iw ji">12</span><span class="iw jj">13</span><span class="iw jk">14</span><span class="iw jl">15</span><span class="iw jm">16</span><span class="iw jn">17</span><span class="iw jo">18</span><span class="iw jp">19</span><span class="iw jq">20</span><span class="iw jr">21</span><span class="iw js">22</span><span class="iw jt">23</span><span class="iw ju">24</span><span class="iw jv">25</span> <div class="language-ecmascript r"> <span class="o u">Regular</span><span class="o v">web</span><span class="o w">component</span><span class="o x">accessor</span><span class="o y">state</span><span class="c it">import</span><span class="q z">{</span><span class="ba kj">define</span><span class="bb q">,</span><span class="bc kj">attr</span><span class="bd q">,</span><span class="be kj">prop</span><span class="bf q">,</span><span class="bg kj">number</span><span class="bh c">import</span><span class="bi q">{</span><span class="bj kj">Fragment</span><span class="bk q">,</span><span class="bl kj">h</span><span class="bm q">,</span><span class="bn kj">render</span><span class="bo q">}</span><span class="bp c">from</span><span class="a bq">"</span><span class="a br">preact</span><span class="a bs">"</span><span class="bt q">;</span><span class="bu o">//</span><span class="bv o">Register</span><span class="bw o">the</span><span class="bx o">class</span><span class="by o">a</span><span class="bz o">a</span><span class="ca o">custom</span><span class="cb o">HTML</span><span class="cc o">tag</span><span class="cd l">@</span><span class="ce m">define</span><span class="cf q">(</span><span class="a cg">"</span><span class="a ch">click</span><span class="a ci">-</span><span class="a cj">counter</span><span class="a ck">"</span><span class="cl q">)</span><span class="c cm">class</span><span class="cn i">ClickCounter</span><span class="c co">extends</span><span class="cp i">HTMLElement</span><span class="cq q">{</span><span class="cr o">//</span><span class="cs o">Public</span><span class="ct o">content</span><span class="cu o">attribute</span><span class="cv o">for</span><span class="cw o">the</span><span class="cx o">initial</span><span class="cy o">value</span><span class="cz l">@</span><span class="da m">attr</span><span class="db q">(</span><span class="dc m">number</span><span class="dd q">(</span><span class="de q">{</span><span class="df kj">min</span><span class="dg l">:</span><span class="b dh">0</span><span class="di q">}</span><span class="dj q">)</span><span class="dk q">)</span><span class="c dl">accessor</span><span class="dm kj">value</span><span class="dn l">=</span><span class="b do">0</span><span class="dp q">;</span><span class="dq o">//</span><span class="dr o">Internal</span><span class="ds o">attribute</span><span class="dt o">for</span><span class="du o">the</span><span class="dv o">current</span><span class="dw o">click</span><span class="dx o">count</span><span class="dy l">@</span><span class="dz m">prop</span><span class="ea q">(</span><span class="eb m">number</span><span class="ec q">(</span><span class="ed q">{</span><span class="ee kj">min</span><span class="ef l">:</span><span class="b eg">0</span><span class="eh q">}</span><span class="ei q">)</span><span class="ej q">)</span><span class="c ek">accessor</span><span class="c el">#</span><span class="em kj">count</span><span class="en l">=</span><span class="c eo">this</span><span class="ep q">.</span><span class="eq kj">value</span><span class="er q">;</span><span class="es o">//</span><span class="et o">Component</span><span class="eu o">'</span><span class="ev o">s</span><span class="ew o">render</span><span class="ex o">logic</span><span class="ey o">,</span><span class="ez o">boilt</span><span class="fa o">with</span><span class="fb o">preact</span><span class="fc q">,</span><span class="fd l">@</span><span class="fe m">connected</span><span class="ff q">(</span><span class="fg q">)</span><span class="fh o">//</span><span class="fi o">run</span><span class="fj o">method</span><span class="fk o">when</span><span class="fl o">the</span><span class="fm o">component</span><span class="fn o">connects</span><span class="fo kj">reactive</span><span class="fp q">,</span><span class="fq l">@</span><span class="fr m">reactive</span><span class="fs q">(</span><span class="ft kj">connected</span><span class="fu q">}</span><span class="c fv">from</span><span class="a fw">"</span><span class="a fx">@</span><span class="a fy">sirpepe</span><span class="a fz">/</span><span class="a ga">ornament</span><span class="a gb">"</span><span class="gc q">;</span><span class="c gd">#</span><span class="ge i">render</span><span class="gf q">(</span><span class="gg q">)</span><span class="gh q">{</span><span class="gi m">render</span><span class="gj q">(</span><span class="gk kk">&lt;</span><span class="gl kk">&gt;</span><span class="g gm">&lt;</span><span class="e gn">button</span><span class="g go">onClick</span><span class="gp l">=</span><span class="gq l">{</span><span class="gr q">(</span><span class="gs q">)</span><span class="gt l">=&gt;</span><span class="c gu">this</span><span class="gv q">.</span><span class="gw kj">#count</span><span class="gx l">++</span><span class="gy l">}</span><span class="g gz">&gt;</span><span class="ha kl">+</span><span class="hb kl">1</span><span class="g hc">&lt;/</span><span class="e hd">button</span><span class="g he">&gt;</span><span class="hf kl">Total</span><span class="hg kl">:</span><span class="g hh">&lt;</span><span class="e hi">b</span><span class="g hj">&gt;</span><span class="hk l">{</span><span class="c hl">this</span><span class="hm q">.</span><span class="hn kj">#count</span><span class="ho l">}</span><span class="g hp">&lt;/</span><span class="e hq">b</span><span class="g hr">&gt;</span><span class="hs kk">&lt;/</span><span class="ht kk">&gt;</span><span class="hu q">,</span><span class="c hv">this</span><span class="hw q">,</span><span class="hx q">)</span><span class="hy q">;</span><span class="hz q">}</span><span class="ia q">}</span><span class="ib q">{</span><span class="ic kj">keys</span><span class="id l">:</span><span class="ie q">[</span><span class="a if">"</span><span class="a ig">#</span><span class="a ih">count</span><span class="a ii">"</span><span class="ij q">]</span><span class="ik q">}</span><span class="il o">#</span><span class="im o">count</span><span class="in o">changes</span><span class="io q">)</span><span class="ip o">//</span><span class="iq o">run</span><span class="ir o">method</span><span class="is o">when</span><span class="iu o">attributes</span><span class="iv o">change</span> </div> <pre class="jw jx">
// Regular web component class
class ClickCounter extends HTMLElement {
}</pre> <pre class="jw jy">
// Regular web component class
class ClickCounter extends HTMLElement {
  // Public accessor for the initial value
  accessor value = 0;

  // Internal state for the current click count
  accessor #count = this.value;
}</pre> <pre class="jw jz">
import { define } from "@sirpepe/ornament";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public accessor for the initial value
  accessor value = 0;

  // Internal state for the current click count
  accessor #count = this.value;
}</pre> <pre class="jw ka">
import { define, attr, prop, number } from "@sirpepe/ornament";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;
}</pre> <pre class="jw kb">
import { define, attr, prop, number } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;
}</pre> <pre class="jw kc">
import { define, attr, prop, number } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;

  // Component's render logic, boilt with preact
  #render() {}
}</pre> <pre class="jw kd">
import { define, attr, prop, number } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;

  // Component's render logic, boilt with preact
  #render() {
    render(&lt;&gt;&lt;/&gt;, this);
  }
}</pre> <pre class="jw ke">
import { define, attr, prop, number } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;

  // Component's render logic, boilt with preact
  #render() {
    render(
      &lt;&gt;
        &lt;button onClick={() =&gt; this.#count++}&gt;+1&lt;/button&gt;
      &lt;/&gt;,
      this,
    );
  }
}</pre> <pre class="jw kf">
import { define, attr, prop, number } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;

  // Component's render logic, boilt with preact
  #render() {
    render(
      &lt;&gt;
        &lt;button onClick={() =&gt; this.#count++}&gt;+1&lt;/button&gt;
        Total: &lt;b&gt;{this.#count}&lt;/b&gt;
      &lt;/&gt;,
      this,
    );
  }
}</pre> <pre class="jw kg">
import { define, attr, prop, number, connected } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;

  // Component's render logic, boilt with preact
  @connected() // run method when the component connects
  #render() {
    render(
      &lt;&gt;
        &lt;button onClick={() =&gt; this.#count++}&gt;+1&lt;/button&gt;
        Total: &lt;b&gt;{this.#count}&lt;/b&gt;
      &lt;/&gt;,
      this,
    );
  }
}
</pre> <pre class="jw kh">
import { define, attr, prop, number, reactive, connected } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;

  // Component's render logic, boilt with preact
  @connected() // run method when the component connects
  @reactive() // run method when attributes change
  #render() {
    render(
      &lt;&gt;
        &lt;button onClick={() =&gt; this.#count++}&gt;+1&lt;/button&gt;
        Total: &lt;b&gt;{this.#count}&lt;/b&gt;
      &lt;/&gt;,
      this,
    );
  }
}</pre> <pre class="jw ki">
import { define, attr, prop, number, reactive, connected } from "@sirpepe/ornament";
import { Fragment, h, render } from "preact";

// Register the class a a custom HTML tag
@define("click-counter")
class ClickCounter extends HTMLElement {
  // Public content attribute for the initial value
  @attr(number({ min: 0 })) accessor value = 0;

  // Internal attribute for the current click count
  @prop(number({ min: 0 })) accessor #count = this.value;

  // Component's render logic, boilt with preact
  @connected() // run method when the component connects
  @reactive({ keys: ["#count"] }) // run method when #count changes
  #render() {
    render(
      &lt;&gt;
        &lt;button onClick={() =&gt; this.#count++}&gt;+1&lt;/button&gt;
        Total: &lt;b&gt;{this.#count}&lt;/b&gt;
      &lt;/&gt;,
      this,
    );
  }
}</pre> </div> </div> <style>.cwxqmrv{--a:var(--cm-align-middle,0);--b:calc(var(--cm-line-height,2.5)*1ch);--c:var(--cm-animation-duration,.5s);--d:var(--cm-animation-timing-function,ease);--e:var(--c)var(--d);color:var(--cm-color,#222);font-style:var(--cm-style,normal);font-weight:var(--cm-weight,normal);font-size:inherit;line-height:var(--b);font-family:var(--cm-font-family,monospace);--f:var(--cm-content-margin-top,0ch);--g:var(--cm-content-margin-right,0ch);--h:var(--cm-content-margin-bottom,0ch);--i:var(--cm-content-margin-left,0ch);--j:var(--cm-line-number-font,normal normal 1em/var(--b)var(--cm-font-family,monospace));--k:var(--cm-line-number-color,#ccc);--l:var(--cm-line-numbers-enabled,0);--m:calc((var(--i) + var(--l)*var(--cm-line-numbers-margin-left,0ch)));--n:calc(var(--l)*var(--cm-line-numbers-margin-right,2ch));--o:var(--f);--p:var(--m);--q:calc(var(--l)*2);--r:var(--f);--s:calc(var(--p) + var(--n) + var(--q)*1ch);--t:calc(var(--s) + var(--g) + 84ch + 1px);--u:calc(var(--f) + var(--h) + var(--b)*25);filter:var(--cm-scene-filter,none);background:var(--cm-scene-background,#fff);--vertical-align:var(--a);--total-rows:25;--total-cols:84;--total-width:var(--t);--total-height:var(--u);transition-duration:var(--c);--z:var(--cm-decoration-text-highlight-foreground-background,#0000);--ba:var(--cm-decoration-text-highlight-background-background,#ff0);--bb:var(--cm-decoration-text-highlight-foreground-filter,none);--bc:var(--cm-decoration-text-highlight-background-filter,none);--bd:var(--cm-decoration-text-highlight-foreground-z-index,40);--be:var(--cm-decoration-text-highlight-background-z-index,10);--bf:var(--cm-decoration-text-highlight-foreground-underline-filter,none);--bg:var(--cm-decoration-text-highlight-background-underline-filter,none);--bh:var(--cm-decoration-text-highlight-foreground-underline-color,#000);--bi:var(--cm-decoration-text-highlight-foreground-underline-width,1);--bj:var(--cm-decoration-text-highlight-foreground-underline-scale,1);--bk:var(--cm-decoration-text-highlight-foreground-underline-offset-y,0);--bl:var(--cm-decoration-text-highlight-background-underline-color,#000);--bm:var(--cm-decoration-text-highlight-background-underline-width,1);--bn:var(--cm-decoration-text-highlight-background-underline-scale,1);--bo:var(--cm-decoration-text-highlight-background-underline-offset-y,0);--bp:var(--cm-decoration-text-error-foreground-background,#0000);--bq:var(--cm-decoration-text-error-background-background,#ff8b8333);--br:var(--cm-decoration-text-error-foreground-filter,none);--bs:var(--cm-decoration-text-error-background-filter,none);--bt:var(--cm-decoration-text-error-foreground-z-index,40);--bu:var(--cm-decoration-text-error-background-z-index,10);--bv:var(--cm-decoration-text-error-foreground-underline-filter,none);--bw:var(--cm-decoration-text-error-background-underline-filter,none);--bx:var(--cm-decoration-text-error-foreground-underline-color,#c00);--by:var(--cm-decoration-text-error-foreground-underline-width,10);--bz:var(--cm-decoration-text-error-foreground-underline-scale,.15);--ca:var(--cm-decoration-text-error-foreground-underline-offset-y,-.5);--cb:visible;--cc:var(--cm-decoration-text-error-background-underline-color,#000);--cd:var(--cm-decoration-text-error-background-underline-width,1);--ce:var(--cm-decoration-text-error-background-underline-scale,1);--cf:var(--cm-decoration-text-error-background-underline-offset-y,0);--cg:var(--cm-decoration-text-ok-foreground-background,#0000);--ch:var(--cm-decoration-text-ok-background-background,#ceffb8);--ci:var(--cm-decoration-text-ok-foreground-filter,none);--cj:var(--cm-decoration-text-ok-background-filter,none);--ck:var(--cm-decoration-text-ok-foreground-z-index,40);--cl:var(--cm-decoration-text-ok-background-z-index,10);--cm:var(--cm-decoration-text-ok-foreground-underline-filter,none);--cn:var(--cm-decoration-text-ok-background-underline-filter,none);--co:var(--cm-decoration-text-ok-foreground-underline-color,#000);--cp:var(--cm-decoration-text-ok-foreground-underline-width,1);--cq:var(--cm-decoration-text-ok-foreground-underline-scale,1);--cr:var(--cm-decoration-text-ok-foreground-underline-offset-y,0);--cs:var(--cm-decoration-text-ok-background-underline-color,#000);--ct:var(--cm-decoration-text-ok-background-underline-width,1);--cu:var(--cm-decoration-text-ok-background-underline-scale,1);--cv:var(--cm-decoration-text-ok-background-underline-offset-y,0);--cw:var(--cm-decoration-text-custom1-foreground-background,#0000);--cx:var(--cm-decoration-text-custom1-background-background,#0000);--cy:var(--cm-decoration-text-custom1-foreground-filter,none);--cz:var(--cm-decoration-text-custom1-background-filter,none);--da:var(--cm-decoration-text-custom1-foreground-z-index,40);--db:var(--cm-decoration-text-custom1-background-z-index,10);--dc:var(--cm-decoration-text-custom1-foreground-underline-filter,none);--dd:var(--cm-decoration-text-custom1-background-underline-filter,none);--de:var(--cm-decoration-text-custom1-foreground-underline-color,#000);--df:var(--cm-decoration-text-custom1-foreground-underline-width,1);--dg:var(--cm-decoration-text-custom1-foreground-underline-scale,1);--dh:var(--cm-decoration-text-custom1-foreground-underline-offset-y,0);--di:var(--cm-decoration-text-custom1-background-underline-color,#000);--dj:var(--cm-decoration-text-custom1-background-underline-width,1);--dk:var(--cm-decoration-text-custom1-background-underline-scale,1);--dl:var(--cm-decoration-text-custom1-background-underline-offset-y,0);--dm:var(--cm-decoration-text-custom2-foreground-background,#0000);--dn:var(--cm-decoration-text-custom2-background-background,#0000);--do:var(--cm-decoration-text-custom2-foreground-filter,none);--dp:var(--cm-decoration-text-custom2-background-filter,none);--dq:var(--cm-decoration-text-custom2-foreground-z-index,40);--dr:var(--cm-decoration-text-custom2-background-z-index,10);--ds:var(--cm-decoration-text-custom2-foreground-underline-filter,none);--dt:var(--cm-decoration-text-custom2-background-underline-filter,none);--du:var(--cm-decoration-text-custom2-foreground-underline-color,#000);--dv:var(--cm-decoration-text-custom2-foreground-underline-width,1);--dw:var(--cm-decoration-text-custom2-foreground-underline-scale,1);--dx:var(--cm-decoration-text-custom2-foreground-underline-offset-y,0);--dy:var(--cm-decoration-text-custom2-background-underline-color,#000);--dz:var(--cm-decoration-text-custom2-background-underline-width,1);--ea:var(--cm-decoration-text-custom2-background-underline-scale,1);--eb:var(--cm-decoration-text-custom2-background-underline-offset-y,0);--ec:var(--cm-decoration-text-custom3-foreground-background,#0000);--ed:var(--cm-decoration-text-custom3-background-background,#0000);--ee:var(--cm-decoration-text-custom3-foreground-filter,none);--ef:var(--cm-decoration-text-custom3-background-filter,none);--eg:var(--cm-decoration-text-custom3-foreground-z-index,40);--eh:var(--cm-decoration-text-custom3-background-z-index,10);--ei:var(--cm-decoration-text-custom3-foreground-underline-filter,none);--ej:var(--cm-decoration-text-custom3-background-underline-filter,none);--ek:var(--cm-decoration-text-custom3-foreground-underline-color,#000);--el:var(--cm-decoration-text-custom3-foreground-underline-width,1);--em:var(--cm-decoration-text-custom3-foreground-underline-scale,1);--en:var(--cm-decoration-text-custom3-foreground-underline-offset-y,0);--eo:var(--cm-decoration-text-custom3-background-underline-color,#000);--ep:var(--cm-decoration-text-custom3-background-underline-width,1);--eq:var(--cm-decoration-text-custom3-background-underline-scale,1);--er:var(--cm-decoration-text-custom3-background-underline-offset-y,0);width:var(--t);height:var(--u);position:relative;& .a{color:var(--cm-string-color,#b60c0c);font-style:var(--cm-string-style,normal);font-weight:var(--cm-string-weight,normal)}& .b{color:var(--cm-number-color,#00806a);font-style:var(--cm-number-style,normal);font-weight:var(--cm-number-weight,normal)}& .c{color:var(--cm-keyword-color,#000);font-style:var(--cm-keyword-style,normal);font-weight:var(--cm-keyword-weight,bold)}& .d{color:var(--cm-alternativeKeyword-color,#072f59);font-style:var(--cm-alternativeKeyword-style,normal);font-weight:var(--cm-alternativeKeyword-weight,bold)}& .e{color:var(--cm-tag-color,#004b52);font-style:var(--cm-tag-style,normal);font-weight:var(--cm-tag-weight,bold)}& .f{color:var(--cm-alternativeTag-color,#06315e);font-style:var(--cm-alternativeTag-style,normal);font-weight:var(--cm-alternativeTag-weight,bold)}& .g{color:var(--cm-attribute-color,#10535a);font-style:var(--cm-attribute-style,normal);font-weight:var(--cm-attribute-weight,normal)}& .h{color:var(--cm-alternativeAttribute-color,#103e6d);font-style:var(--cm-alternativeAttribute-style,normal);font-weight:var(--cm-alternativeAttribute-weight,normal)}& .i{color:var(--cm-declaration-color,#bd0561);font-style:var(--cm-declaration-style,normal);font-weight:var(--cm-declaration-weight,bold)}& .j{color:var(--cm-literal-color,#9d26d9);font-style:var(--cm-literal-style,normal);font-weight:var(--cm-literal-weight,normal)}& .k{color:var(--cm-value-color,#03381a);font-style:var(--cm-value-style,italic);font-weight:var(--cm-value-weight,normal)}& .l{color:var(--cm-operator-color,#902);font-style:var(--cm-operator-style,normal);font-weight:var(--cm-operator-weight,normal)}& .m{color:var(--cm-invocation-color,#05c);font-style:var(--cm-invocation-style,normal);font-weight:var(--cm-invocation-weight,normal)}& .n{color:var(--cm-type-color,#036578);font-style:var(--cm-type-style,normal);font-weight:var(--cm-type-weight,normal)}& .o{color:var(--cm-comment-color,gray);font-style:var(--cm-comment-style,italic);font-weight:var(--cm-comment-weight,normal)}& .p{color:var(--cm-alternativeComment-color,gray);font-style:var(--cm-alternativeComment-style,italic);font-weight:var(--cm-alternativeComment-weight,bold)}& .q{color:var(--cm-punctuation-color,#404040);font-style:var(--cm-punctuation-style,normal);font-weight:var(--cm-punctuation-weight,normal)}& svg[preserveAspectRatio]{transform:translateY(calc(var(--v)*1ch));width:6ch;height:6ch}& path{stroke:var(--w);stroke-width:var(--x);fill:none;stroke-linejoin:round}& rect{transform-origin:50%;transform:scale(var(--y))}& .r{z-index:20;-webkit-user-select:none;user-select:none;position:relative}& .s{width:100%;transition:transform var(--e);position:absolute}&.frame0 .s,&.frame1 .s,&.frame2 .s,&.frame3 .s,&.frame4 .s,&.frame5 .s,&.frame6 .s,&.frame7 .s,&.frame8 .s,&.frame9 .s,&.frame10 .s,&.frame11 .s{transform:translateY(calc(var(--a)*(var(--total-height)/2 - var(--current-height)/2)))}&.frame0{--current-rows:3;--current-cols:40;--current-width:calc(var(--i) + var(--g) + 40ch);--current-height:calc(var(--f) + var(--h) + var(--b)*3)}&.frame1{--current-rows:8;--current-cols:47;--current-width:calc(var(--i) + var(--g) + 47ch);--current-height:calc(var(--f) + var(--h) + var(--b)*8)}&.frame2{--current-rows:11;--current-cols:47;--current-width:calc(var(--i) + var(--g) + 47ch);--current-height:calc(var(--f) + var(--h) + var(--b)*11)}&.frame3{--current-rows:11;--current-cols:63;--current-width:calc(var(--i) + var(--g) + 63ch);--current-height:calc(var(--f) + var(--h) + var(--b)*11)}&.frame4{--current-rows:12;--current-cols:63;--current-width:calc(var(--i) + var(--g) + 63ch);--current-height:calc(var(--f) + var(--h) + var(--b)*12)}&.frame5{--current-rows:15;--current-cols:63;--current-width:calc(var(--i) + var(--g) + 63ch);--current-height:calc(var(--f) + var(--h) + var(--b)*15)}&.frame6{--current-rows:17;--current-cols:63;--current-width:calc(var(--i) + var(--g) + 63ch);--current-height:calc(var(--f) + var(--h) + var(--b)*17)}&.frame7{--current-rows:22;--current-cols:63;--current-width:calc(var(--i) + var(--g) + 63ch);--current-height:calc(var(--f) + var(--h) + var(--b)*22)}&.frame8{--current-rows:23;--current-cols:63;--current-width:calc(var(--i) + var(--g) + 63ch);--current-height:calc(var(--f) + var(--h) + var(--b)*23)}&.frame9{--current-rows:25;--current-cols:74;--current-width:calc(var(--i) + var(--g) + 74ch);--current-height:calc(var(--f) + var(--h) + var(--b)*25)}&.frame10,&.frame11{--current-rows:25;--current-cols:84;--current-width:calc(var(--i) + var(--g) + 84ch);--current-height:calc(var(--f) + var(--h) + var(--b)*25)}& .t{filter:var(--cm-code-filter,none)}& .r span{top:var(--r);left:var(--s);opacity:var(--es,0);transform:translate(calc(1ch*var(--et,0)),calc(var(--b)*var(--eu,0)));transition:transform var(--e),opacity var(--e);position:absolute}&.frame0 .u,&.frame1 .u{--es:1;--et:3}&.frame0 .v,&.frame1 .v{--es:1;--et:11}&.frame0 .w,&.frame1 .w,&.frame3 .bb,&.frame4 .bb,&.frame5 .bb,&.frame6 .bb,&.frame7 .bb,&.frame8 .bb,&.frame9 .bb,&.frame10 .bb,&.frame11 .bb{--es:1;--et:15}&.frame0 .x,&.frame1 .bw{--eu:2;--et:12}&.frame0 .y{--eu:5;--et:14}&.frame0 .z,&.frame1 .z{--et:7}&.frame0 .ba,&.frame1 .ba{--et:9}&.frame0 .bb,&.frame2 .w,&.frame2 .bb,&.frame11 .w{--et:15}&.frame0 .bc,&.frame2 .bc{--et:17}&.frame0 .bd,&.frame2 .bd{--et:21}&.frame0 .be,&.frame1 .fw,&.frame2 .be{--et:23}&.frame0 .bf,&.frame2 .bf{--et:27}&.frame0 .bg,&.frame2 .bg{--et:29}&.frame0 .bh,&.frame3 .bh{--eu:1}&.frame0 .bi,&.frame3 .bi{--eu:1;--et:7}&.frame0 .bj,&.frame3 .bj{--eu:1;--et:9}&.frame0 .bk,&.frame3 .bk{--eu:1;--et:17}&.frame0 .bl,&.frame3 .bl{--eu:1;--et:19}&.frame0 .bm,&.frame3 .bm{--eu:1;--et:20}&.frame0 .bn,&.frame3 .bn{--eu:1;--et:22}&.frame0 .bo,&.frame3 .bo{--eu:1;--et:29}&.frame0 .bp,&.frame3 .bp{--eu:1;--et:31}&.frame0 .bq,&.frame3 .bq{--eu:1;--et:36}&.frame0 .br,&.frame3 .br{--eu:1;--et:37}&.frame0 .bs,&.frame3 .bs{--eu:1;--et:43}&.frame0 .bt,&.frame3 .bt{--eu:1;--et:44}&.frame0 .bu,&.frame1 .bu,&.frame2 .it,&.frame3 .it,&.frame4 .it,&.frame5 .it,&.frame6 .it,&.frame7 .it,&.frame8 .it,&.frame9 .it,&.frame10 .it,&.frame11 .it,&.frame0 .ix,&.frame0 .iy,&.frame0 .iz,&.frame1 .ix,&.frame1 .iy,&.frame1 .iz,&.frame1 .ja,&.frame1 .jb,&.frame1 .jc,&.frame1 .jd,&.frame1 .je,&.frame2 .ix,&.frame2 .iy,&.frame2 .iz,&.frame2 .ja,&.frame2 .jb,&.frame2 .jc,&.frame2 .jd,&.frame2 .je,&.frame2 .jf,&.frame2 .jg,&.frame2 .jh,&.frame3 .ix,&.frame3 .iy,&.frame3 .iz,&.frame3 .ja,&.frame3 .jb,&.frame3 .jc,&.frame3 .jd,&.frame3 .je,&.frame3 .jf,&.frame3 .jg,&.frame3 .jh,&.frame4 .ix,&.frame4 .iy,&.frame4 .iz,&.frame4 .ja,&.frame4 .jb,&.frame4 .jc,&.frame4 .jd,&.frame4 .je,&.frame4 .jf,&.frame4 .jg,&.frame4 .jh,&.frame4 .ji,&.frame5 .ix,&.frame5 .iy,&.frame5 .iz,&.frame5 .ja,&.frame5 .jb,&.frame5 .jc,&.frame5 .jd,&.frame5 .je,&.frame5 .jf,&.frame5 .jg,&.frame5 .jh,&.frame5 .ji,&.frame5 .jj,&.frame5 .jk,&.frame5 .jl,&.frame6 .ix,&.frame6 .iy,&.frame6 .iz,&.frame6 .ja,&.frame6 .jb,&.frame6 .jc,&.frame6 .jd,&.frame6 .je,&.frame6 .jf,&.frame6 .jg,&.frame6 .jh,&.frame6 .ji,&.frame6 .jj,&.frame6 .jk,&.frame6 .jl,&.frame6 .jm,&.frame6 .jn,&.frame7 .ix,&.frame7 .iy,&.frame7 .iz,&.frame7 .ja,&.frame7 .jb,&.frame7 .jc,&.frame7 .jd,&.frame7 .je,&.frame7 .jf,&.frame7 .jg,&.frame7 .jh,&.frame7 .ji,&.frame7 .jj,&.frame7 .jk,&.frame7 .jl,&.frame7 .jm,&.frame7 .jn,&.frame7 .jo,&.frame7 .jp,&.frame7 .jq,&.frame7 .jr,&.frame7 .js,&.frame8 .ix,&.frame8 .iy,&.frame8 .iz,&.frame8 .ja,&.frame8 .jb,&.frame8 .jc,&.frame8 .jd,&.frame8 .je,&.frame8 .jf,&.frame8 .jg,&.frame8 .jh,&.frame8 .ji,&.frame8 .jj,&.frame8 .jk,&.frame8 .jl,&.frame8 .jm,&.frame8 .jn,&.frame8 .jo,&.frame8 .jp,&.frame8 .jq,&.frame8 .jr,&.frame8 .js,&.frame8 .jt,&.frame9 .ix,&.frame9 .iy,&.frame9 .iz,&.frame9 .ja,&.frame9 .jb,&.frame9 .jc,&.frame9 .jd,&.frame9 .je,&.frame9 .jf,&.frame9 .jg,&.frame9 .jh,&.frame9 .ji,&.frame9 .jj,&.frame9 .jk,&.frame9 .jl,&.frame9 .jm,&.frame9 .jn,&.frame9 .jo,&.frame9 .jp,&.frame9 .jq,&.frame9 .jr,&.frame9 .js,&.frame9 .jt,&.frame9 .ju,&.frame9 .jv,&.frame10 .ix,&.frame10 .iy,&.frame10 .iz,&.frame10 .ja,&.frame10 .jb,&.frame10 .jc,&.frame10 .jd,&.frame10 .je,&.frame10 .jf,&.frame10 .jg,&.frame10 .jh,&.frame10 .ji,&.frame10 .jj,&.frame10 .jk,&.frame10 .jl,&.frame10 .jm,&.frame10 .jn,&.frame10 .jo,&.frame10 .jp,&.frame10 .jq,&.frame10 .jr,&.frame10 .js,&.frame10 .jt,&.frame10 .ju,&.frame10 .jv,&.frame11 .ix,&.frame11 .iy,&.frame11 .iz,&.frame11 .ja,&.frame11 .jb,&.frame11 .jc,&.frame11 .jd,&.frame11 .je,&.frame11 .jf,&.frame11 .jg,&.frame11 .jh,&.frame11 .ji,&.frame11 .jj,&.frame11 .jk,&.frame11 .jl,&.frame11 .jm,&.frame11 .jn,&.frame11 .jo,&.frame11 .jp,&.frame11 .jq,&.frame11 .jr,&.frame11 .js,&.frame11 .jt,&.frame11 .ju,&.frame11 .jv{--es:1}&.frame0 .bv{--eu:3;--et:3}&.frame0 .bw{--eu:3;--et:12}&.frame0 .bx,&.frame1 .bx,&.frame2 .fy{--es:1;--et:25}&.frame0 .by,&.frame1 .ck{--eu:3;--et:22}&.frame0 .bz{--eu:3;--et:24}&.frame0 .ca{--eu:3;--et:26}&.frame0 .cb{--eu:3;--et:33}&.frame0 .cc{--eu:3;--et:38}&.frame0 .cd{--eu:4}&.frame0 .ce{--eu:4;--et:1}&.frame0 .cf{--eu:4;--et:7}&.frame0 .cg{--eu:4;--et:8}&.frame0 .ch{--eu:4;--et:9}&.frame0 .ci{--eu:4;--et:14}&.frame0 .cj{--eu:4;--et:15}&.frame0 .ck{--eu:4;--et:22}&.frame0 .cl{--eu:4;--et:23}&.frame0 .cm,&.frame1 .cm,&.frame4 .bh,&.frame5 .bh,&.frame6 .bh,&.frame7 .bh,&.frame8 .bh,&.frame9 .bh,&.frame10 .bh,&.frame11 .bh{--es:1;--eu:1}&.frame0 .cn,&.frame1 .cn{--es:1;--eu:1;--et:6}&.frame0 .co,&.frame1 .co,&.frame4 .bl,&.frame5 .bl,&.frame6 .bl,&.frame7 .bl,&.frame8 .bl,&.frame9 .bl,&.frame10 .bl,&.frame11 .bl{--es:1;--eu:1;--et:19}&.frame0 .cp,&.frame1 .cp{--es:1;--eu:1;--et:27}&.frame0 .cq,&.frame1 .cq{--es:1;--eu:1;--et:39}&.frame0 .cr{--eu:2;--et:2}&.frame0 .cs{--eu:2;--et:5}&.frame0 .ct,&.frame0 .em{--eu:6;--et:12}&.frame0 .cu,&.frame0 .eo,&.frame2 .dg{--eu:6;--et:20}&.frame0 .cv{--eu:2;--et:21}&.frame0 .cw{--eu:2;--et:25}&.frame0 .cx{--eu:2;--et:29}&.frame0 .cy{--eu:2;--et:37}&.frame0 .cz{--eu:7;--et:2}&.frame0 .da{--eu:7;--et:3}&.frame0 .db{--eu:7;--et:7}&.frame0 .dc{--eu:7;--et:8}&.frame0 .dd{--eu:7;--et:14}&.frame0 .de{--eu:7;--et:15}&.frame0 .df{--eu:7;--et:17}&.frame0 .dg{--eu:7;--et:20}&.frame0 .dh{--eu:7;--et:22}&.frame0 .di{--eu:7;--et:24}&.frame0 .dj{--eu:7;--et:25}&.frame0 .dk{--eu:7;--et:26}&.frame0 .dl{--eu:3;--et:2}&.frame0 .dm{--eu:3;--et:11}&.frame0 .dn{--eu:3;--et:17}&.frame0 .do{--eu:3;--et:19}&.frame0 .dp{--eu:3;--et:20}&.frame0 .dq{--eu:5;--et:2}&.frame0 .dr{--eu:5;--et:5}&.frame0 .ds,&.frame2 .ec{--eu:9;--et:14}&.frame0 .dt,&.frame2 .cu{--eu:5;--et:20}&.frame0 .du{--eu:5;--et:24}&.frame0 .dv{--eu:5;--et:28}&.frame0 .dw{--eu:5;--et:36}&.frame0 .dx{--eu:5;--et:42}&.frame0 .dy{--eu:10;--et:2}&.frame0 .dz{--eu:10;--et:3}&.frame0 .ea{--eu:10;--et:7}&.frame0 .eb{--eu:10;--et:8}&.frame0 .ec{--eu:10;--et:14}&.frame0 .ed{--eu:10;--et:15}&.frame0 .ee{--eu:10;--et:17}&.frame0 .ef{--eu:10;--et:20}&.frame0 .eg{--eu:10;--et:22}&.frame0 .eh{--eu:10;--et:24}&.frame0 .ei{--eu:10;--et:25}&.frame0 .ej{--eu:10;--et:26}&.frame0 .ek,&.frame2 .cz{--eu:6;--et:2}&.frame0 .el{--eu:6;--et:11}&.frame0 .en{--eu:6;--et:18}&.frame0 .ep,&.frame2 .di{--eu:6;--et:24}&.frame0 .eq,&.frame2 .dj{--eu:6;--et:25}&.frame0 .er{--eu:6;--et:30}&.frame0 .es,&.frame4 .es{--eu:12;--et:2}&.frame0 .et,&.frame4 .et{--eu:12;--et:5}&.frame0 .eu,&.frame4 .eu{--eu:12;--et:14}&.frame0 .ev,&.frame4 .ev{--eu:12;--et:15}&.frame0 .ew,&.frame4 .ew{--eu:12;--et:17}&.frame0 .ex,&.frame4 .ex{--eu:12;--et:24}&.frame0 .ey,&.frame4 .ey{--eu:12;--et:29}&.frame0 .ez,&.frame4 .ez{--eu:12;--et:31}&.frame0 .fa,&.frame4 .fa{--eu:12;--et:37}&.frame0 .fb,&.frame4 .fb{--eu:12;--et:42}&.frame0 .fc,&.frame8 .fc{--et:35}&.frame0 .fd,&.frame4 .gd,&.frame8 .fd{--eu:13;--et:2}&.frame0 .fe,&.frame4 .ge,&.frame8 .fe{--eu:13;--et:3}&.frame0 .ff,&.frame4 .gh,&.frame8 .ff{--eu:13;--et:12}&.frame0 .fg,&.frame4 .hz,&.frame8 .fg{--eu:13;--et:13}&.frame0 .fh,&.frame8 .fh{--eu:13;--et:15}&.frame0 .fi,&.frame8 .fi{--eu:13;--et:18}&.frame0 .fj,&.frame8 .fj{--eu:13;--et:22}&.frame0 .fk,&.frame8 .fk{--eu:13;--et:29}&.frame0 .fl,&.frame8 .fl{--eu:13;--et:34}&.frame0 .fm,&.frame8 .fm{--eu:13;--et:38}&.frame0 .fn,&.frame8 .fn{--eu:13;--et:48}&.frame0 .fo,&.frame8 .ft,&.frame9 .fo{--et:37}&.frame0 .fp,&.frame9 .fp{--et:45}&.frame0 .fq,&.frame9 .fq{--eu:14;--et:2}&.frame0 .fr,&.frame9 .fr{--eu:14;--et:3}&.frame0 .fs,&.frame5 .gk,&.frame9 .fs{--eu:14;--et:11}&.frame0 .ft{--et:47}&.frame0 .fu{--et:57}&.frame0 .fv{--et:59}&.frame0 .fw{--et:64}&.frame0 .fx{--et:65}&.frame0 .fy{--et:66}&.frame0 .fz{--et:73}&.frame0 .ga{--et:74}&.frame0 .gb{--et:82}&.frame0 .gc{--et:83}&.frame0 .gd{--eu:15;--et:2}&.frame0 .ge{--eu:15;--et:3}&.frame0 .gf{--eu:15;--et:9}&.frame0 .gg{--eu:15;--et:10}&.frame0 .gh{--eu:15;--et:12}&.frame0 .gi{--eu:16;--et:4}&.frame0 .gj{--eu:16;--et:10}&.frame0 .gk{--eu:17;--et:6}&.frame0 .gl{--eu:17;--et:7}&.frame0 .gm{--eu:18;--et:8}&.frame0 .gn{--eu:18;--et:9}&.frame0 .go{--eu:18;--et:16}&.frame0 .gp{--eu:18;--et:23}&.frame0 .gq{--eu:18;--et:24}&.frame0 .gr{--eu:18;--et:25}&.frame0 .gs{--eu:18;--et:26}&.frame0 .gt{--eu:18;--et:28}&.frame0 .gu{--eu:18;--et:31}&.frame0 .gv{--eu:18;--et:35}&.frame0 .gw{--eu:18;--et:36}&.frame0 .gx{--eu:18;--et:42}&.frame0 .gy{--eu:18;--et:44}&.frame0 .gz{--eu:18;--et:45}&.frame0 .ha{--eu:18;--et:46}&.frame0 .hb{--eu:18;--et:47}&.frame0 .hc{--eu:18;--et:48}&.frame0 .hd{--eu:18;--et:50}&.frame0 .he{--eu:18;--et:56}&.frame0 .hf{--eu:19;--et:8}&.frame0 .hg{--eu:19;--et:13}&.frame0 .hh{--eu:19;--et:15}&.frame0 .hi{--eu:19;--et:16}&.frame0 .hj{--eu:19;--et:17}&.frame0 .hk{--eu:19;--et:18}&.frame0 .hl{--eu:19;--et:19}&.frame0 .hm{--eu:19;--et:23}&.frame0 .hn{--eu:19;--et:24}&.frame0 .ho{--eu:19;--et:30}&.frame0 .hp{--eu:19;--et:31}&.frame0 .hq{--eu:19;--et:33}&.frame0 .hr{--eu:19;--et:34}&.frame0 .hs{--eu:20;--et:6}&.frame0 .ht{--eu:20;--et:8}&.frame0 .hu{--eu:20;--et:9}&.frame0 .hv{--eu:21;--et:6}&.frame0 .hw{--eu:21;--et:10}&.frame0 .hx{--eu:22;--et:4}&.frame0 .hy{--eu:22;--et:5}&.frame0 .hz{--eu:23;--et:2}&.frame0 .ia,&.frame2 .bu,&.frame3 .bu{--es:1;--eu:2}&.frame0 .ib,&.frame5 .gl,&.frame9 .io,&.frame10 .ib{--eu:14;--et:12}&.frame0 .ic,&.frame9 .ip,&.frame10 .ic{--eu:14;--et:14}&.frame0 .id,&.frame5 .hv,&.frame10 .id{--eu:14;--et:18}&.frame0 .ie,&.frame10 .ie{--eu:14;--et:20}&.frame0 .if,&.frame9 .ir,&.frame10 .if{--eu:14;--et:21}&.frame0 .ig,&.frame5 .hx,&.frame10 .ig{--eu:14;--et:22}&.frame0 .ih,&.frame5 .hy,&.frame10 .ih{--eu:14;--et:23}&.frame0 .ii,&.frame9 .is,&.frame10 .ii{--eu:14;--et:28}&.frame0 .ij,&.frame10 .ij{--eu:14;--et:29}&.frame0 .ik,&.frame10 .ik{--eu:14;--et:31}&.frame0 .il,&.frame10 .il{--eu:14;--et:53}&.frame0 .im,&.frame10 .im{--eu:14;--et:54}&.frame0 .in,&.frame10 .in{--eu:14;--et:60}&.frame0 .io{--eu:14;--et:32}&.frame0 .ip{--eu:14;--et:34}&.frame0 .iq{--eu:14;--et:37}&.frame0 .ir{--eu:14;--et:41}&.frame0 .is{--eu:14;--et:48}&.frame1 .x,&.frame2 .bw,&.frame3 .bw{--es:1;--eu:2;--et:12}&.frame1 .y{--es:1;--eu:5;--et:14}&.frame1 .bv{--eu:2;--et:3}&.frame1 .by{--eu:2;--et:22}&.frame1 .bz{--eu:2;--et:24}&.frame1 .ca{--eu:2;--et:26}&.frame1 .cb{--eu:2;--et:33}&.frame1 .cc{--eu:2;--et:38}&.frame1 .cd{--eu:3}&.frame1 .ce{--eu:3;--et:1}&.frame1 .cf{--eu:3;--et:7}&.frame1 .cg{--eu:3;--et:8}&.frame1 .ch{--eu:3;--et:9}&.frame1 .ci{--eu:3;--et:14}&.frame1 .cj{--eu:3;--et:15}&.frame1 .cl{--eu:3;--et:23}&.frame1 .cr{--es:1;--eu:2;--et:2}&.frame1 .cs{--es:1;--eu:2;--et:5}&.frame1 .cv{--es:1;--eu:2;--et:21}&.frame1 .cw{--es:1;--eu:2;--et:25}&.frame1 .cx{--es:1;--eu:2;--et:29}&.frame1 .cy{--es:1;--eu:2;--et:37}&.frame1 .dl{--es:1;--eu:3;--et:2}&.frame1 .dm{--es:1;--eu:3;--et:11}&.frame1 .dn{--es:1;--eu:3;--et:17}&.frame1 .do{--es:1;--eu:3;--et:19}&.frame1 .dp{--es:1;--eu:3;--et:20}&.frame1 .dq,&.frame2 .cr,&.frame3 .cr{--es:1;--eu:5;--et:2}&.frame1 .dr,&.frame2 .cs,&.frame3 .cs{--es:1;--eu:5;--et:5}&.frame1 .dt,&.frame3 .cu{--es:1;--eu:5;--et:20}&.frame1 .du{--es:1;--eu:5;--et:24}&.frame1 .dv{--es:1;--eu:5;--et:28}&.frame1 .dw{--es:1;--eu:5;--et:36}&.frame1 .dx{--es:1;--eu:5;--et:42}&.frame1 .ek,&.frame2 .dl,&.frame3 .cz,&.frame4 .cr,&.frame5 .cr,&.frame6 .cr,&.frame7 .cr,&.frame8 .cr,&.frame9 .cr,&.frame10 .cr,&.frame11 .cr{--es:1;--eu:6;--et:2}&.frame1 .el,&.frame2 .dm{--es:1;--eu:6;--et:11}&.frame1 .em,&.frame4 .ct,&.frame5 .ct,&.frame6 .ct,&.frame7 .ct,&.frame8 .ct,&.frame9 .ct,&.frame10 .ct,&.frame11 .ct{--es:1;--eu:6;--et:12}&.frame1 .en{--es:1;--eu:6;--et:18}&.frame1 .eo,&.frame2 .dp,&.frame3 .dg,&.frame4 .cu,&.frame5 .cu,&.frame6 .cu,&.frame7 .cu,&.frame8 .cu,&.frame9 .cu,&.frame10 .cu,&.frame11 .cu{--es:1;--eu:6;--et:20}&.frame1 .ep,&.frame3 .di{--es:1;--eu:6;--et:24}&.frame1 .eq,&.frame3 .dj{--es:1;--eu:6;--et:25}&.frame1 .er,&.frame4 .cv,&.frame5 .cv,&.frame6 .cv,&.frame7 .cv,&.frame8 .cv,&.frame9 .cv,&.frame10 .cv,&.frame11 .cv{--es:1;--eu:6;--et:30}&.frame1 .fu{--et:16}&.frame1 .fv{--et:18}&.frame1 .fx{--et:24}&.frame1 .fy{--et:25}&.frame1 .fz{--et:32}&.frame1 .ga{--et:33}&.frame1 .gb{--et:41}&.frame1 .gc{--et:42}&.frame1 .ia{--es:1;--eu:7}&.frame2 .u,&.frame11 .u{--et:3}&.frame2 .v,&.frame11 .v{--et:11}&.frame2 .x,&.frame3 .ct{--es:1;--eu:5;--et:12}&.frame2 .y,&.frame3 .ds{--es:1;--eu:8;--et:14}&.frame2 .z,&.frame3 .z,&.frame4 .z,&.frame5 .z,&.frame6 .z,&.frame7 .z,&.frame8 .z,&.frame9 .z,&.frame10 .z,&.frame11 .z{--es:1;--et:7}&.frame2 .ba,&.frame3 .ba,&.frame4 .ba,&.frame5 .ba,&.frame6 .ba,&.frame7 .ba,&.frame8 .ba,&.frame9 .ba,&.frame10 .ba,&.frame11 .ba{--es:1;--et:9}&.frame2 .bv,&.frame3 .bv{--es:1;--eu:2;--et:3}&.frame2 .bx,&.frame3 .bx{--es:1;--eu:2;--et:16}&.frame2 .by,&.frame3 .by{--es:1;--eu:2;--et:22}&.frame2 .bz,&.frame3 .bz{--es:1;--eu:2;--et:24}&.frame2 .ca,&.frame3 .ca{--es:1;--eu:2;--et:26}&.frame2 .cb,&.frame3 .cb{--es:1;--eu:2;--et:33}&.frame2 .cc,&.frame3 .cc{--es:1;--eu:2;--et:38}&.frame2 .cd,&.frame3 .cd,&.frame4 .bu,&.frame5 .bu,&.frame6 .bu,&.frame7 .bu,&.frame8 .bu,&.frame9 .bu,&.frame10 .bu,&.frame11 .bu{--es:1;--eu:3}&.frame2 .ce,&.frame3 .ce{--es:1;--eu:3;--et:1}&.frame2 .cf,&.frame3 .cf{--es:1;--eu:3;--et:7}&.frame2 .cg,&.frame3 .cg{--es:1;--eu:3;--et:8}&.frame2 .ch,&.frame3 .ch{--es:1;--eu:3;--et:9}&.frame2 .ci,&.frame3 .ci{--es:1;--eu:3;--et:14}&.frame2 .cj,&.frame3 .cj{--es:1;--eu:3;--et:15}&.frame2 .ck,&.frame3 .ck,&.frame4 .by,&.frame5 .by,&.frame6 .by,&.frame7 .by,&.frame8 .by,&.frame9 .by,&.frame10 .by,&.frame11 .by{--es:1;--eu:3;--et:22}&.frame2 .cl,&.frame3 .cl{--es:1;--eu:3;--et:23}&.frame2 .cm,&.frame3 .cm,&.frame4 .cd,&.frame5 .cd,&.frame6 .cd,&.frame7 .cd,&.frame8 .cd,&.frame9 .cd,&.frame10 .cd,&.frame11 .cd{--es:1;--eu:4}&.frame2 .cn,&.frame3 .cn{--es:1;--eu:4;--et:6}&.frame2 .co,&.frame3 .co{--es:1;--eu:4;--et:19}&.frame2 .cp,&.frame3 .cp{--es:1;--eu:4;--et:27}&.frame2 .cq,&.frame3 .cq{--es:1;--eu:4;--et:39}&.frame2 .ct,&.frame3 .x{--eu:5;--et:12}&.frame2 .cv{--es:1;--eu:5;--et:21}&.frame2 .cw{--es:1;--eu:5;--et:25}&.frame2 .cx{--es:1;--eu:5;--et:29}&.frame2 .cy{--es:1;--eu:5;--et:37}&.frame2 .da{--eu:6;--et:3}&.frame2 .db{--eu:6;--et:7}&.frame2 .dc{--eu:6;--et:8}&.frame2 .dd{--eu:6;--et:14}&.frame2 .de{--eu:6;--et:15}&.frame2 .df{--eu:6;--et:17}&.frame2 .dh{--eu:6;--et:22}&.frame2 .dk{--eu:6;--et:26}&.frame2 .dn,&.frame3 .df{--es:1;--eu:6;--et:17}&.frame2 .do{--es:1;--eu:6;--et:19}&.frame2 .dq,&.frame3 .dq{--es:1;--eu:8;--et:2}&.frame2 .dr,&.frame3 .dr{--es:1;--eu:8;--et:5}&.frame2 .ds,&.frame3 .y{--eu:8;--et:14}&.frame2 .dt{--es:1;--eu:8;--et:20}&.frame2 .du,&.frame3 .dt{--es:1;--eu:8;--et:24}&.frame2 .dv,&.frame3 .du{--es:1;--eu:8;--et:28}&.frame2 .dw{--es:1;--eu:8;--et:36}&.frame2 .dx{--es:1;--eu:8;--et:42}&.frame2 .dy{--eu:9;--et:2}&.frame2 .dz{--eu:9;--et:3}&.frame2 .ea{--eu:9;--et:7}&.frame2 .eb{--eu:9;--et:8}&.frame2 .ed{--eu:9;--et:15}&.frame2 .ee{--eu:9;--et:17}&.frame2 .ef{--eu:9;--et:20}&.frame2 .eg{--eu:9;--et:22}&.frame2 .eh{--eu:9;--et:24}&.frame2 .ei{--eu:9;--et:25}&.frame2 .ej{--eu:9;--et:26}&.frame2 .ek,&.frame3 .dy,&.frame4 .dq,&.frame5 .dq,&.frame6 .dq,&.frame7 .dq,&.frame8 .dq,&.frame9 .dq,&.frame10 .dq,&.frame11 .dq{--es:1;--eu:9;--et:2}&.frame2 .el{--es:1;--eu:9;--et:11}&.frame2 .em{--es:1;--eu:9;--et:12}&.frame2 .en{--es:1;--eu:9;--et:18}&.frame2 .eo,&.frame3 .ef{--es:1;--eu:9;--et:20}&.frame2 .ep,&.frame3 .eh,&.frame4 .dt,&.frame5 .dt,&.frame6 .dt,&.frame7 .dt,&.frame8 .dt,&.frame9 .dt,&.frame10 .dt,&.frame11 .dt{--es:1;--eu:9;--et:24}&.frame2 .eq,&.frame3 .ei{--es:1;--eu:9;--et:25}&.frame2 .er{--es:1;--eu:9;--et:30}&.frame2 .fu{--es:1;--et:16}&.frame2 .fv{--es:1;--et:18}&.frame2 .fw,&.frame3 .be,&.frame4 .be,&.frame5 .be,&.frame6 .be,&.frame7 .be,&.frame8 .be,&.frame9 .be,&.frame10 .be,&.frame11 .be{--es:1;--et:23}&.frame2 .fx{--es:1;--et:24}&.frame2 .fz{--es:1;--et:32}&.frame2 .ga{--es:1;--et:33}&.frame2 .gb{--es:1;--et:41}&.frame2 .gc{--es:1;--et:42}&.frame2 .ia,&.frame3 .ia{--es:1;--eu:10}&.frame3 .bc,&.frame4 .bc,&.frame5 .bc,&.frame6 .bc,&.frame7 .bc,&.frame8 .bc,&.frame9 .bc,&.frame10 .bc,&.frame11 .bc{--es:1;--et:17}&.frame3 .bd,&.frame4 .bd,&.frame5 .bd,&.frame6 .bd,&.frame7 .bd,&.frame8 .bd,&.frame9 .bd,&.frame10 .bd,&.frame11 .bd{--es:1;--et:21}&.frame3 .bf,&.frame4 .bf,&.frame5 .bf,&.frame6 .bf,&.frame7 .bf,&.frame8 .bf,&.frame9 .bf,&.frame10 .bf,&.frame11 .bf{--es:1;--et:27}&.frame3 .bg,&.frame4 .bg,&.frame5 .bg,&.frame6 .bg,&.frame7 .bg,&.frame8 .bg,&.frame9 .bg,&.frame10 .bg,&.frame11 .bg{--es:1;--et:29}&.frame3 .cv{--es:1;--eu:5;--et:30}&.frame3 .cw{--es:1;--eu:5;--et:34}&.frame3 .cx{--es:1;--eu:5;--et:38}&.frame3 .cy{--es:1;--eu:5;--et:46}&.frame3 .da{--es:1;--eu:6;--et:3}&.frame3 .db{--es:1;--eu:6;--et:7}&.frame3 .dc{--es:1;--eu:6;--et:8}&.frame3 .dd{--es:1;--eu:6;--et:14}&.frame3 .de{--es:1;--eu:6;--et:15}&.frame3 .dh{--es:1;--eu:6;--et:22}&.frame3 .dk{--es:1;--eu:6;--et:26}&.frame3 .dl{--es:1;--eu:6;--et:28}&.frame3 .dm{--es:1;--eu:6;--et:37}&.frame3 .dn{--es:1;--eu:6;--et:43}&.frame3 .do{--es:1;--eu:6;--et:45}&.frame3 .dp,&.frame4 .cy,&.frame5 .cy,&.frame6 .cy,&.frame7 .cy,&.frame8 .cy,&.frame9 .cy,&.frame10 .cy,&.frame11 .cy{--es:1;--eu:6;--et:46}&.frame3 .dv{--es:1;--eu:8;--et:32}&.frame3 .dw{--es:1;--eu:8;--et:40}&.frame3 .dx{--es:1;--eu:8;--et:46}&.frame3 .dz{--es:1;--eu:9;--et:3}&.frame3 .ea{--es:1;--eu:9;--et:7}&.frame3 .eb{--es:1;--eu:9;--et:8}&.frame3 .ec,&.frame4 .ds,&.frame5 .ds,&.frame6 .ds,&.frame7 .ds,&.frame8 .ds,&.frame9 .ds,&.frame10 .ds,&.frame11 .ds{--es:1;--eu:9;--et:14}&.frame3 .ed{--es:1;--eu:9;--et:15}&.frame3 .ee{--es:1;--eu:9;--et:17}&.frame3 .eg{--es:1;--eu:9;--et:22}&.frame3 .ej{--es:1;--eu:9;--et:26}&.frame3 .ek,&.frame4 .du,&.frame5 .du,&.frame6 .du,&.frame7 .du,&.frame8 .du,&.frame9 .du,&.frame10 .du,&.frame11 .du{--es:1;--eu:9;--et:28}&.frame3 .el{--es:1;--eu:9;--et:37}&.frame3 .em{--es:1;--eu:9;--et:38}&.frame3 .en{--es:1;--eu:9;--et:44}&.frame3 .eo,&.frame4 .dx,&.frame5 .dx,&.frame6 .dx,&.frame7 .dx,&.frame8 .dx,&.frame9 .dx,&.frame10 .dx,&.frame11 .dx{--es:1;--eu:9;--et:46}&.frame3 .ep{--es:1;--eu:9;--et:50}&.frame3 .eq{--es:1;--eu:9;--et:51}&.frame3 .er{--es:1;--eu:9;--et:56}&.frame3 .fu,&.frame4 .fu,&.frame5 .fu,&.frame6 .fu,&.frame7 .fu,&.frame8 .fu{--es:1;--et:36}&.frame3 .fv,&.frame4 .fv,&.frame5 .fv,&.frame6 .fv,&.frame7 .fv,&.frame8 .fv{--es:1;--et:38}&.frame3 .fw,&.frame4 .fw,&.frame5 .fw,&.frame6 .fw,&.frame7 .fw,&.frame8 .fw{--es:1;--et:43}&.frame3 .fx,&.frame4 .fx,&.frame5 .fx,&.frame6 .fx,&.frame7 .fx,&.frame8 .fx{--es:1;--et:44}&.frame3 .fy,&.frame4 .fy,&.frame5 .fy,&.frame6 .fy,&.frame7 .fy,&.frame8 .fy,&.frame10 .fp,&.frame11 .fp{--es:1;--et:45}&.frame3 .fz,&.frame4 .fz,&.frame5 .fz,&.frame6 .fz,&.frame7 .fz,&.frame8 .fz{--es:1;--et:52}&.frame3 .ga,&.frame4 .ga,&.frame5 .ga,&.frame6 .ga,&.frame7 .ga,&.frame8 .ga{--es:1;--et:53}&.frame3 .gb,&.frame4 .gb,&.frame5 .gb,&.frame6 .gb,&.frame7 .gb,&.frame8 .gb{--es:1;--et:61}&.frame3 .gc,&.frame4 .gc,&.frame5 .gc,&.frame6 .gc,&.frame7 .gc,&.frame8 .gc{--es:1;--et:62}&.frame4 .bi,&.frame5 .bi,&.frame6 .bi,&.frame7 .bi,&.frame8 .bi,&.frame9 .bi,&.frame10 .bi,&.frame11 .bi{--es:1;--eu:1;--et:7}&.frame4 .bj,&.frame5 .bj,&.frame6 .bj,&.frame7 .bj,&.frame8 .bj,&.frame9 .bj,&.frame10 .bj,&.frame11 .bj{--es:1;--eu:1;--et:9}&.frame4 .bk,&.frame5 .bk,&.frame6 .bk,&.frame7 .bk,&.frame8 .bk,&.frame9 .bk,&.frame10 .bk,&.frame11 .bk{--es:1;--eu:1;--et:17}&.frame4 .bm,&.frame5 .bm,&.frame6 .bm,&.frame7 .bm,&.frame8 .bm,&.frame9 .bm,&.frame10 .bm,&.frame11 .bm{--es:1;--eu:1;--et:20}&.frame4 .bn,&.frame5 .bn,&.frame6 .bn,&.frame7 .bn,&.frame8 .bn,&.frame9 .bn,&.frame10 .bn,&.frame11 .bn{--es:1;--eu:1;--et:22}&.frame4 .bo,&.frame5 .bo,&.frame6 .bo,&.frame7 .bo,&.frame8 .bo,&.frame9 .bo,&.frame10 .bo,&.frame11 .bo{--es:1;--eu:1;--et:29}&.frame4 .bp,&.frame5 .bp,&.frame6 .bp,&.frame7 .bp,&.frame8 .bp,&.frame9 .bp,&.frame10 .bp,&.frame11 .bp{--es:1;--eu:1;--et:31}&.frame4 .bq,&.frame5 .bq,&.frame6 .bq,&.frame7 .bq,&.frame8 .bq,&.frame9 .bq,&.frame10 .bq,&.frame11 .bq{--es:1;--eu:1;--et:36}&.frame4 .br,&.frame5 .br,&.frame6 .br,&.frame7 .br,&.frame8 .br,&.frame9 .br,&.frame10 .br,&.frame11 .br{--es:1;--eu:1;--et:37}&.frame4 .bs,&.frame5 .bs,&.frame6 .bs,&.frame7 .bs,&.frame8 .bs,&.frame9 .bs,&.frame10 .bs,&.frame11 .bs{--es:1;--eu:1;--et:43}&.frame4 .bt,&.frame5 .bt,&.frame6 .bt,&.frame7 .bt,&.frame8 .bt,&.frame9 .bt,&.frame10 .bt,&.frame11 .bt{--es:1;--eu:1;--et:44}&.frame4 .bv,&.frame5 .bv,&.frame6 .bv,&.frame7 .bv,&.frame8 .bv,&.frame9 .bv,&.frame10 .bv,&.frame11 .bv{--es:1;--eu:3;--et:3}&.frame4 .bw,&.frame5 .bw,&.frame6 .bw,&.frame7 .bw,&.frame8 .bw,&.frame9 .bw,&.frame10 .bw,&.frame11 .bw{--es:1;--eu:3;--et:12}&.frame4 .bx,&.frame5 .bx,&.frame6 .bx,&.frame7 .bx,&.frame8 .bx,&.frame9 .bx,&.frame10 .bx,&.frame11 .bx{--es:1;--eu:3;--et:16}&.frame4 .bz,&.frame5 .bz,&.frame6 .bz,&.frame7 .bz,&.frame8 .bz,&.frame9 .bz,&.frame10 .bz,&.frame11 .bz{--es:1;--eu:3;--et:24}&.frame4 .ca,&.frame5 .ca,&.frame6 .ca,&.frame7 .ca,&.frame8 .ca,&.frame9 .ca,&.frame10 .ca,&.frame11 .ca{--es:1;--eu:3;--et:26}&.frame4 .cb,&.frame5 .cb,&.frame6 .cb,&.frame7 .cb,&.frame8 .cb,&.frame9 .cb,&.frame10 .cb,&.frame11 .cb{--es:1;--eu:3;--et:33}&.frame4 .cc,&.frame5 .cc,&.frame6 .cc,&.frame7 .cc,&.frame8 .cc,&.frame9 .cc,&.frame10 .cc,&.frame11 .cc{--es:1;--eu:3;--et:38}&.frame4 .ce,&.frame5 .ce,&.frame6 .ce,&.frame7 .ce,&.frame8 .ce,&.frame9 .ce,&.frame10 .ce,&.frame11 .ce{--es:1;--eu:4;--et:1}&.frame4 .cf,&.frame5 .cf,&.frame6 .cf,&.frame7 .cf,&.frame8 .cf,&.frame9 .cf,&.frame10 .cf,&.frame11 .cf{--es:1;--eu:4;--et:7}&.frame4 .cg,&.frame5 .cg,&.frame6 .cg,&.frame7 .cg,&.frame8 .cg,&.frame9 .cg,&.frame10 .cg,&.frame11 .cg{--es:1;--eu:4;--et:8}&.frame4 .ch,&.frame5 .ch,&.frame6 .ch,&.frame7 .ch,&.frame8 .ch,&.frame9 .ch,&.frame10 .ch,&.frame11 .ch{--es:1;--eu:4;--et:9}&.frame4 .ci,&.frame5 .ci,&.frame6 .ci,&.frame7 .ci,&.frame8 .ci,&.frame9 .ci,&.frame10 .ci,&.frame11 .ci{--es:1;--eu:4;--et:14}&.frame4 .cj,&.frame5 .cj,&.frame6 .cj,&.frame7 .cj,&.frame8 .cj,&.frame9 .cj,&.frame10 .cj,&.frame11 .cj{--es:1;--eu:4;--et:15}&.frame4 .ck,&.frame5 .ck,&.frame6 .ck,&.frame7 .ck,&.frame8 .ck,&.frame9 .ck,&.frame10 .ck,&.frame11 .ck{--es:1;--eu:4;--et:22}&.frame4 .cl,&.frame5 .cl,&.frame6 .cl,&.frame7 .cl,&.frame8 .cl,&.frame9 .cl,&.frame10 .cl,&.frame11 .cl{--es:1;--eu:4;--et:23}&.frame4 .cm,&.frame5 .cm,&.frame6 .cm,&.frame7 .cm,&.frame8 .cm,&.frame9 .cm,&.frame10 .cm,&.frame11 .cm{--es:1;--eu:5}&.frame4 .cn,&.frame5 .cn,&.frame6 .cn,&.frame7 .cn,&.frame8 .cn,&.frame9 .cn,&.frame10 .cn,&.frame11 .cn{--es:1;--eu:5;--et:6}&.frame4 .co,&.frame5 .co,&.frame6 .co,&.frame7 .co,&.frame8 .co,&.frame9 .co,&.frame10 .co,&.frame11 .co{--es:1;--eu:5;--et:19}&.frame4 .cp,&.frame5 .cp,&.frame6 .cp,&.frame7 .cp,&.frame8 .cp,&.frame9 .cp,&.frame10 .cp,&.frame11 .cp{--es:1;--eu:5;--et:27}&.frame4 .cq,&.frame5 .cq,&.frame6 .cq,&.frame7 .cq,&.frame8 .cq,&.frame9 .cq,&.frame10 .cq,&.frame11 .cq{--es:1;--eu:5;--et:39}&.frame4 .cs,&.frame5 .cs,&.frame6 .cs,&.frame7 .cs,&.frame8 .cs,&.frame9 .cs,&.frame10 .cs,&.frame11 .cs{--es:1;--eu:6;--et:5}&.frame4 .cw,&.frame5 .cw,&.frame6 .cw,&.frame7 .cw,&.frame8 .cw,&.frame9 .cw,&.frame10 .cw,&.frame11 .cw{--es:1;--eu:6;--et:34}&.frame4 .cx,&.frame5 .cx,&.frame6 .cx,&.frame7 .cx,&.frame8 .cx,&.frame9 .cx,&.frame10 .cx,&.frame11 .cx{--es:1;--eu:6;--et:38}&.frame4 .cz,&.frame5 .cz,&.frame6 .cz,&.frame7 .cz,&.frame8 .cz,&.frame9 .cz,&.frame10 .cz,&.frame11 .cz{--es:1;--eu:7;--et:2}&.frame4 .da,&.frame5 .da,&.frame6 .da,&.frame7 .da,&.frame8 .da,&.frame9 .da,&.frame10 .da,&.frame11 .da{--es:1;--eu:7;--et:3}&.frame4 .db,&.frame5 .db,&.frame6 .db,&.frame7 .db,&.frame8 .db,&.frame9 .db,&.frame10 .db,&.frame11 .db{--es:1;--eu:7;--et:7}&.frame4 .dc,&.frame5 .dc,&.frame6 .dc,&.frame7 .dc,&.frame8 .dc,&.frame9 .dc,&.frame10 .dc,&.frame11 .dc{--es:1;--eu:7;--et:8}&.frame4 .dd,&.frame5 .dd,&.frame6 .dd,&.frame7 .dd,&.frame8 .dd,&.frame9 .dd,&.frame10 .dd,&.frame11 .dd{--es:1;--eu:7;--et:14}&.frame4 .de,&.frame5 .de,&.frame6 .de,&.frame7 .de,&.frame8 .de,&.frame9 .de,&.frame10 .de,&.frame11 .de{--es:1;--eu:7;--et:15}&.frame4 .df,&.frame5 .df,&.frame6 .df,&.frame7 .df,&.frame8 .df,&.frame9 .df,&.frame10 .df,&.frame11 .df{--es:1;--eu:7;--et:17}&.frame4 .dg,&.frame5 .dg,&.frame6 .dg,&.frame7 .dg,&.frame8 .dg,&.frame9 .dg,&.frame10 .dg,&.frame11 .dg{--es:1;--eu:7;--et:20}&.frame4 .dh,&.frame5 .dh,&.frame6 .dh,&.frame7 .dh,&.frame8 .dh,&.frame9 .dh,&.frame10 .dh,&.frame11 .dh{--es:1;--eu:7;--et:22}&.frame4 .di,&.frame5 .di,&.frame6 .di,&.frame7 .di,&.frame8 .di,&.frame9 .di,&.frame10 .di,&.frame11 .di{--es:1;--eu:7;--et:24}&.frame4 .dj,&.frame5 .dj,&.frame6 .dj,&.frame7 .dj,&.frame8 .dj,&.frame9 .dj,&.frame10 .dj,&.frame11 .dj{--es:1;--eu:7;--et:25}&.frame4 .dk,&.frame5 .dk,&.frame6 .dk,&.frame7 .dk,&.frame8 .dk,&.frame9 .dk,&.frame10 .dk,&.frame11 .dk{--es:1;--eu:7;--et:26}&.frame4 .dl,&.frame5 .dl,&.frame6 .dl,&.frame7 .dl,&.frame8 .dl,&.frame9 .dl,&.frame10 .dl,&.frame11 .dl{--es:1;--eu:7;--et:28}&.frame4 .dm,&.frame5 .dm,&.frame6 .dm,&.frame7 .dm,&.frame8 .dm,&.frame9 .dm,&.frame10 .dm,&.frame11 .dm{--es:1;--eu:7;--et:37}&.frame4 .dn,&.frame5 .dn,&.frame6 .dn,&.frame7 .dn,&.frame8 .dn,&.frame9 .dn,&.frame10 .dn,&.frame11 .dn{--es:1;--eu:7;--et:43}&.frame4 .do,&.frame5 .do,&.frame6 .do,&.frame7 .do,&.frame8 .do,&.frame9 .do,&.frame10 .do,&.frame11 .do{--es:1;--eu:7;--et:45}&.frame4 .dp,&.frame5 .dp,&.frame6 .dp,&.frame7 .dp,&.frame8 .dp,&.frame9 .dp,&.frame10 .dp,&.frame11 .dp{--es:1;--eu:7;--et:46}&.frame4 .dr,&.frame5 .dr,&.frame6 .dr,&.frame7 .dr,&.frame8 .dr,&.frame9 .dr,&.frame10 .dr,&.frame11 .dr{--es:1;--eu:9;--et:5}&.frame4 .dv,&.frame5 .dv,&.frame6 .dv,&.frame7 .dv,&.frame8 .dv,&.frame9 .dv,&.frame10 .dv,&.frame11 .dv{--es:1;--eu:9;--et:32}&.frame4 .dw,&.frame5 .dw,&.frame6 .dw,&.frame7 .dw,&.frame8 .dw,&.frame9 .dw,&.frame10 .dw,&.frame11 .dw{--es:1;--eu:9;--et:40}&.frame4 .dy,&.frame5 .dy,&.frame6 .dy,&.frame7 .dy,&.frame8 .dy,&.frame9 .dy,&.frame10 .dy,&.frame11 .dy{--es:1;--eu:10;--et:2}&.frame4 .dz,&.frame5 .dz,&.frame6 .dz,&.frame7 .dz,&.frame8 .dz,&.frame9 .dz,&.frame10 .dz,&.frame11 .dz{--es:1;--eu:10;--et:3}&.frame4 .ea,&.frame5 .ea,&.frame6 .ea,&.frame7 .ea,&.frame8 .ea,&.frame9 .ea,&.frame10 .ea,&.frame11 .ea{--es:1;--eu:10;--et:7}&.frame4 .eb,&.frame5 .eb,&.frame6 .eb,&.frame7 .eb,&.frame8 .eb,&.frame9 .eb,&.frame10 .eb,&.frame11 .eb{--es:1;--eu:10;--et:8}&.frame4 .ec,&.frame5 .ec,&.frame6 .ec,&.frame7 .ec,&.frame8 .ec,&.frame9 .ec,&.frame10 .ec,&.frame11 .ec{--es:1;--eu:10;--et:14}&.frame4 .ed,&.frame5 .ed,&.frame6 .ed,&.frame7 .ed,&.frame8 .ed,&.frame9 .ed,&.frame10 .ed,&.frame11 .ed{--es:1;--eu:10;--et:15}&.frame4 .ee,&.frame5 .ee,&.frame6 .ee,&.frame7 .ee,&.frame8 .ee,&.frame9 .ee,&.frame10 .ee,&.frame11 .ee{--es:1;--eu:10;--et:17}&.frame4 .ef,&.frame5 .ef,&.frame6 .ef,&.frame7 .ef,&.frame8 .ef,&.frame9 .ef,&.frame10 .ef,&.frame11 .ef{--es:1;--eu:10;--et:20}&.frame4 .eg,&.frame5 .eg,&.frame6 .eg,&.frame7 .eg,&.frame8 .eg,&.frame9 .eg,&.frame10 .eg,&.frame11 .eg{--es:1;--eu:10;--et:22}&.frame4 .eh,&.frame5 .eh,&.frame6 .eh,&.frame7 .eh,&.frame8 .eh,&.frame9 .eh,&.frame10 .eh,&.frame11 .eh{--es:1;--eu:10;--et:24}&.frame4 .ei,&.frame5 .ei,&.frame6 .ei,&.frame7 .ei,&.frame8 .ei,&.frame9 .ei,&.frame10 .ei,&.frame11 .ei{--es:1;--eu:10;--et:25}&.frame4 .ej,&.frame5 .ej,&.frame6 .ej,&.frame7 .ej,&.frame8 .ej,&.frame9 .ej,&.frame10 .ej,&.frame11 .ej{--es:1;--eu:10;--et:26}&.frame4 .ek,&.frame5 .ek,&.frame6 .ek,&.frame7 .ek,&.frame8 .ek,&.frame9 .ek,&.frame10 .ek,&.frame11 .ek{--es:1;--eu:10;--et:28}&.frame4 .el,&.frame5 .el,&.frame6 .el,&.frame7 .el,&.frame8 .el,&.frame9 .el,&.frame10 .el,&.frame11 .el{--es:1;--eu:10;--et:37}&.frame4 .em,&.frame5 .em,&.frame6 .em,&.frame7 .em,&.frame8 .em,&.frame9 .em,&.frame10 .em,&.frame11 .em{--es:1;--eu:10;--et:38}&.frame4 .en,&.frame5 .en,&.frame6 .en,&.frame7 .en,&.frame8 .en,&.frame9 .en,&.frame10 .en,&.frame11 .en{--es:1;--eu:10;--et:44}&.frame4 .eo,&.frame5 .eo,&.frame6 .eo,&.frame7 .eo,&.frame8 .eo,&.frame9 .eo,&.frame10 .eo,&.frame11 .eo{--es:1;--eu:10;--et:46}&.frame4 .ep,&.frame5 .ep,&.frame6 .ep,&.frame7 .ep,&.frame8 .ep,&.frame9 .ep,&.frame10 .ep,&.frame11 .ep{--es:1;--eu:10;--et:50}&.frame4 .eq,&.frame5 .eq,&.frame6 .eq,&.frame7 .eq,&.frame8 .eq,&.frame9 .eq,&.frame10 .eq,&.frame11 .eq{--es:1;--eu:10;--et:51}&.frame4 .er,&.frame5 .er,&.frame6 .er,&.frame7 .er,&.frame8 .er,&.frame9 .er,&.frame10 .er,&.frame11 .er{--es:1;--eu:10;--et:56}&.frame4 .gf{--eu:13;--et:9}&.frame4 .gg{--eu:13;--et:10}&.frame4 .ia{--es:1;--eu:11}&.frame5 .es,&.frame6 .es,&.frame7 .es,&.frame8 .es,&.frame9 .es,&.frame10 .es,&.frame11 .es{--es:1;--eu:12;--et:2}&.frame5 .et,&.frame6 .et,&.frame7 .et,&.frame8 .et,&.frame9 .et,&.frame10 .et,&.frame11 .et{--es:1;--eu:12;--et:5}&.frame5 .eu,&.frame6 .eu,&.frame7 .eu,&.frame8 .eu,&.frame9 .eu,&.frame10 .eu,&.frame11 .eu{--es:1;--eu:12;--et:14}&.frame5 .ev,&.frame6 .ev,&.frame7 .ev,&.frame8 .ev,&.frame9 .ev,&.frame10 .ev,&.frame11 .ev{--es:1;--eu:12;--et:15}&.frame5 .ew,&.frame6 .ew,&.frame7 .ew,&.frame8 .ew,&.frame9 .ew,&.frame10 .ew,&.frame11 .ew{--es:1;--eu:12;--et:17}&.frame5 .ex,&.frame6 .ex,&.frame7 .ex,&.frame8 .ex,&.frame9 .ex,&.frame10 .ex,&.frame11 .ex{--es:1;--eu:12;--et:24}&.frame5 .ey,&.frame6 .ey,&.frame7 .ey,&.frame8 .ey,&.frame9 .ey,&.frame10 .ey,&.frame11 .ey{--es:1;--eu:12;--et:29}&.frame5 .ez,&.frame6 .ez,&.frame7 .ez,&.frame8 .ez,&.frame9 .ez,&.frame10 .ez,&.frame11 .ez{--es:1;--eu:12;--et:31}&.frame5 .fa,&.frame6 .fa,&.frame7 .fa,&.frame8 .fa,&.frame9 .fa,&.frame10 .fa,&.frame11 .fa{--es:1;--eu:12;--et:37}&.frame5 .fb,&.frame6 .fb,&.frame7 .fb,&.frame8 .fb,&.frame9 .fb,&.frame10 .fb,&.frame11 .fb{--es:1;--eu:12;--et:42}&.frame5 .gd,&.frame6 .gd,&.frame7 .gd,&.frame8 .gd,&.frame9 .fd,&.frame10 .fd,&.frame11 .fd{--es:1;--eu:13;--et:2}&.frame5 .ge,&.frame6 .ge,&.frame7 .ge,&.frame8 .ge,&.frame9 .fe,&.frame10 .fe,&.frame11 .fe{--es:1;--eu:13;--et:3}&.frame5 .gf,&.frame6 .gf,&.frame7 .gf,&.frame8 .gf{--es:1;--eu:13;--et:9}&.frame5 .gg,&.frame6 .gg,&.frame7 .gg,&.frame8 .gg{--es:1;--eu:13;--et:10}&.frame5 .gh,&.frame6 .gh,&.frame7 .gh,&.frame8 .gh,&.frame9 .ff,&.frame10 .ff,&.frame11 .ff{--es:1;--eu:13;--et:12}&.frame5 .gi{--eu:14;--et:4}&.frame5 .gj{--eu:14;--et:10}&.frame5 .hs{--eu:14;--et:13}&.frame5 .ht{--eu:14;--et:15}&.frame5 .hu{--eu:14;--et:16}&.frame5 .hz,&.frame9 .fg,&.frame10 .fg,&.frame11 .fg{--es:1;--eu:13;--et:13}&.frame5 .ia{--es:1;--eu:14}&.frame6 .gi,&.frame7 .gi,&.frame8 .gi{--es:1;--eu:14;--et:4}&.frame6 .gj,&.frame7 .gj,&.frame8 .gj,&.frame9 .gg{--es:1;--eu:14;--et:10}&.frame6 .gk,&.frame10 .fs,&.frame11 .fs{--es:1;--eu:14;--et:11}&.frame6 .gl,&.frame9 .gh,&.frame10 .io,&.frame11 .ib{--es:1;--eu:14;--et:12}&.frame6 .gm{--eu:16;--et:8}&.frame6 .gn{--eu:16;--et:9}&.frame6 .go{--eu:16;--et:16}&.frame6 .gp{--eu:16;--et:23}&.frame6 .gq{--eu:16;--et:24}&.frame6 .gr{--eu:16;--et:25}&.frame6 .gs{--eu:16;--et:26}&.frame6 .gt{--eu:16;--et:28}&.frame6 .gu{--eu:16;--et:31}&.frame6 .gv{--eu:16;--et:35}&.frame6 .gw{--eu:16;--et:36}&.frame6 .gx{--eu:16;--et:42}&.frame6 .gy{--eu:16;--et:44}&.frame6 .gz{--eu:16;--et:45}&.frame6 .ha{--eu:16;--et:46}&.frame6 .hb{--eu:16;--et:47}&.frame6 .hc{--eu:16;--et:48}&.frame6 .hd{--eu:16;--et:50}&.frame6 .he{--eu:16;--et:56}&.frame6 .hs{--es:1;--eu:14;--et:13}&.frame6 .ht{--es:1;--eu:14;--et:15}&.frame6 .hu{--es:1;--eu:14;--et:16}&.frame6 .hv,&.frame11 .id{--es:1;--eu:14;--et:18}&.frame6 .hw{--eu:18;--et:10}&.frame6 .hx,&.frame11 .ig{--es:1;--eu:14;--et:22}&.frame6 .hy,&.frame11 .ih{--es:1;--eu:14;--et:23}&.frame6 .hz,&.frame10 .gd,&.frame11 .gd{--es:1;--eu:15;--et:2}&.frame6 .ia{--es:1;--eu:16}&.frame7 .gk,&.frame8 .gk{--es:1;--eu:15;--et:6}&.frame7 .gl,&.frame8 .gl{--es:1;--eu:15;--et:7}&.frame7 .gm,&.frame8 .gm{--es:1;--eu:16;--et:8}&.frame7 .gn,&.frame8 .gn{--es:1;--eu:16;--et:9}&.frame7 .go,&.frame8 .go{--es:1;--eu:16;--et:16}&.frame7 .gp,&.frame8 .gp{--es:1;--eu:16;--et:23}&.frame7 .gq,&.frame8 .gq{--es:1;--eu:16;--et:24}&.frame7 .gr,&.frame8 .gr{--es:1;--eu:16;--et:25}&.frame7 .gs,&.frame8 .gs{--es:1;--eu:16;--et:26}&.frame7 .gt,&.frame8 .gt{--es:1;--eu:16;--et:28}&.frame7 .gu,&.frame8 .gu{--es:1;--eu:16;--et:31}&.frame7 .gv,&.frame8 .gv{--es:1;--eu:16;--et:35}&.frame7 .gw,&.frame8 .gw{--es:1;--eu:16;--et:36}&.frame7 .gx,&.frame8 .gx{--es:1;--eu:16;--et:42}&.frame7 .gy,&.frame8 .gy{--es:1;--eu:16;--et:44}&.frame7 .gz,&.frame8 .gz{--es:1;--eu:16;--et:45}&.frame7 .ha,&.frame8 .ha{--es:1;--eu:16;--et:46}&.frame7 .hb,&.frame8 .hb{--es:1;--eu:16;--et:47}&.frame7 .hc,&.frame8 .hc{--es:1;--eu:16;--et:48}&.frame7 .hd,&.frame8 .hd{--es:1;--eu:16;--et:50}&.frame7 .he,&.frame8 .he{--es:1;--eu:16;--et:56}&.frame7 .hf{--eu:17;--et:8}&.frame7 .hg{--eu:17;--et:13}&.frame7 .hh{--eu:17;--et:15}&.frame7 .hi{--eu:17;--et:16}&.frame7 .hj{--eu:17;--et:17}&.frame7 .hk{--eu:17;--et:18}&.frame7 .hl{--eu:17;--et:19}&.frame7 .hm{--eu:17;--et:23}&.frame7 .hn{--eu:17;--et:24}&.frame7 .ho{--eu:17;--et:30}&.frame7 .hp{--eu:17;--et:31}&.frame7 .hq{--eu:17;--et:33}&.frame7 .hr{--eu:17;--et:34}&.frame7 .hs,&.frame10 .gk,&.frame11 .gk{--es:1;--eu:17;--et:6}&.frame7 .ht,&.frame8 .hf,&.frame9 .gm{--es:1;--eu:17;--et:8}&.frame7 .hu,&.frame9 .gn{--es:1;--eu:17;--et:9}&.frame7 .hv,&.frame8 .hs{--es:1;--eu:18;--et:6}&.frame7 .hw{--es:1;--eu:18;--et:10}&.frame7 .hx{--es:1;--eu:19;--et:4}&.frame7 .hy{--es:1;--eu:19;--et:5}&.frame7 .hz{--es:1;--eu:20;--et:2}&.frame7 .ia{--es:1;--eu:21}&.frame8 .hg{--es:1;--eu:17;--et:13}&.frame8 .hh{--es:1;--eu:17;--et:15}&.frame8 .hi,&.frame9 .go{--es:1;--eu:17;--et:16}&.frame8 .hj{--es:1;--eu:17;--et:17}&.frame8 .hk{--es:1;--eu:17;--et:18}&.frame8 .hl{--es:1;--eu:17;--et:19}&.frame8 .hm,&.frame9 .gp{--es:1;--eu:17;--et:23}&.frame8 .hn,&.frame9 .gq{--es:1;--eu:17;--et:24}&.frame8 .ho{--es:1;--eu:17;--et:30}&.frame8 .hp,&.frame9 .gu{--es:1;--eu:17;--et:31}&.frame8 .hq{--es:1;--eu:17;--et:33}&.frame8 .hr{--es:1;--eu:17;--et:34}&.frame8 .ht,&.frame9 .hf,&.frame10 .gm,&.frame11 .gm{--es:1;--eu:18;--et:8}&.frame8 .hu,&.frame10 .gn,&.frame11 .gn{--es:1;--eu:18;--et:9}&.frame8 .hv,&.frame9 .hs{--es:1;--eu:19;--et:6}&.frame8 .hw{--es:1;--eu:19;--et:10}&.frame8 .hx{--es:1;--eu:20;--et:4}&.frame8 .hy{--es:1;--eu:20;--et:5}&.frame8 .hz{--es:1;--eu:21;--et:2}&.frame8 .ia{--es:1;--eu:22}&.frame9 .iu,&.frame11 .iu{--eu:14;--et:33}&.frame9 .iv,&.frame11 .iv{--eu:14;--et:44}&.frame9 .fc,&.frame10 .fc,&.frame11 .fc{--es:1;--et:35}&.frame9 .fh,&.frame10 .fh,&.frame11 .fh{--es:1;--eu:13;--et:15}&.frame9 .fi,&.frame10 .fi,&.frame11 .fi{--es:1;--eu:13;--et:18}&.frame9 .fj,&.frame10 .fj,&.frame11 .fj{--es:1;--eu:13;--et:22}&.frame9 .fk,&.frame10 .fk,&.frame11 .fk{--es:1;--eu:13;--et:29}&.frame9 .fl,&.frame10 .fl,&.frame11 .fl{--es:1;--eu:13;--et:34}&.frame9 .fm,&.frame10 .fm,&.frame11 .fm{--es:1;--eu:13;--et:38}&.frame9 .fn,&.frame10 .fn,&.frame11 .fn{--es:1;--eu:13;--et:48}&.frame9 .ft,&.frame10 .fo,&.frame11 .fo{--es:1;--et:37}&.frame9 .fu,&.frame10 .ft,&.frame11 .ft{--es:1;--et:47}&.frame9 .fv{--es:1;--et:49}&.frame9 .fw{--es:1;--et:54}&.frame9 .fx{--es:1;--et:55}&.frame9 .fy{--es:1;--et:56}&.frame9 .fz{--es:1;--et:63}&.frame9 .ga,&.frame10 .fw,&.frame11 .fw{--es:1;--et:64}&.frame9 .gb{--es:1;--et:72}&.frame9 .gc,&.frame10 .fz,&.frame11 .fz{--es:1;--et:73}&.frame9 .gd,&.frame10 .fq,&.frame11 .fq{--es:1;--eu:14;--et:2}&.frame9 .ge,&.frame10 .fr,&.frame11 .fr{--es:1;--eu:14;--et:3}&.frame9 .gf{--es:1;--eu:14;--et:9}&.frame9 .gi{--es:1;--eu:15;--et:4}&.frame9 .gj,&.frame10 .gg,&.frame11 .gg{--es:1;--eu:15;--et:10}&.frame9 .gk{--es:1;--eu:16;--et:6}&.frame9 .gl{--es:1;--eu:16;--et:7}&.frame9 .gr{--es:1;--eu:17;--et:25}&.frame9 .gs{--es:1;--eu:17;--et:26}&.frame9 .gt{--es:1;--eu:17;--et:28}&.frame9 .gv{--es:1;--eu:17;--et:35}&.frame9 .gw{--es:1;--eu:17;--et:36}&.frame9 .gx{--es:1;--eu:17;--et:42}&.frame9 .gy{--es:1;--eu:17;--et:44}&.frame9 .gz{--es:1;--eu:17;--et:45}&.frame9 .ha{--es:1;--eu:17;--et:46}&.frame9 .hb{--es:1;--eu:17;--et:47}&.frame9 .hc{--es:1;--eu:17;--et:48}&.frame9 .hd{--es:1;--eu:17;--et:50}&.frame9 .he{--es:1;--eu:17;--et:56}&.frame9 .hg{--es:1;--eu:18;--et:13}&.frame9 .hh{--es:1;--eu:18;--et:15}&.frame9 .hi,&.frame10 .go,&.frame11 .go{--es:1;--eu:18;--et:16}&.frame9 .hj{--es:1;--eu:18;--et:17}&.frame9 .hk{--es:1;--eu:18;--et:18}&.frame9 .hl{--es:1;--eu:18;--et:19}&.frame9 .hm,&.frame10 .gp,&.frame11 .gp{--es:1;--eu:18;--et:23}&.frame9 .hn,&.frame10 .gq,&.frame11 .gq{--es:1;--eu:18;--et:24}&.frame9 .ho{--es:1;--eu:18;--et:30}&.frame9 .hp,&.frame10 .gu,&.frame11 .gu{--es:1;--eu:18;--et:31}&.frame9 .hq{--es:1;--eu:18;--et:33}&.frame9 .hr{--es:1;--eu:18;--et:34}&.frame9 .ht,&.frame10 .hf,&.frame11 .hf{--es:1;--eu:19;--et:8}&.frame9 .hu{--es:1;--eu:19;--et:9}&.frame9 .hv,&.frame10 .hs,&.frame11 .hs{--es:1;--eu:20;--et:6}&.frame9 .hw{--es:1;--eu:20;--et:10}&.frame9 .hx{--es:1;--eu:21;--et:4}&.frame9 .hy{--es:1;--eu:21;--et:5}&.frame9 .hz{--es:1;--eu:22;--et:2}&.frame9 .ia{--es:1;--eu:23}&.frame9 .iq{--eu:14;--et:17}&.frame10 .iu{--es:1;--eu:14;--et:33}&.frame10 .iv{--es:1;--eu:14;--et:44}&.frame10 .fu,&.frame11 .fu{--es:1;--et:57}&.frame10 .fv,&.frame11 .fv{--es:1;--et:59}&.frame10 .fx,&.frame11 .fx{--es:1;--et:65}&.frame10 .fy,&.frame11 .fy{--es:1;--et:66}&.frame10 .ga,&.frame11 .ga{--es:1;--et:74}&.frame10 .gb,&.frame11 .gb{--es:1;--et:82}&.frame10 .gc,&.frame11 .gc{--es:1;--et:83}&.frame10 .ge,&.frame11 .ge{--es:1;--eu:15;--et:3}&.frame10 .gf,&.frame11 .gf{--es:1;--eu:15;--et:9}&.frame10 .gh,&.frame11 .gh{--es:1;--eu:15;--et:12}&.frame10 .gi,&.frame11 .gi{--es:1;--eu:16;--et:4}&.frame10 .gj,&.frame11 .gj{--es:1;--eu:16;--et:10}&.frame10 .gl,&.frame11 .gl{--es:1;--eu:17;--et:7}&.frame10 .gr,&.frame11 .gr{--es:1;--eu:18;--et:25}&.frame10 .gs,&.frame11 .gs{--es:1;--eu:18;--et:26}&.frame10 .gt,&.frame11 .gt{--es:1;--eu:18;--et:28}&.frame10 .gv,&.frame11 .gv{--es:1;--eu:18;--et:35}&.frame10 .gw,&.frame11 .gw{--es:1;--eu:18;--et:36}&.frame10 .gx,&.frame11 .gx{--es:1;--eu:18;--et:42}&.frame10 .gy,&.frame11 .gy{--es:1;--eu:18;--et:44}&.frame10 .gz,&.frame11 .gz{--es:1;--eu:18;--et:45}&.frame10 .ha,&.frame11 .ha{--es:1;--eu:18;--et:46}&.frame10 .hb,&.frame11 .hb{--es:1;--eu:18;--et:47}&.frame10 .hc,&.frame11 .hc{--es:1;--eu:18;--et:48}&.frame10 .hd,&.frame11 .hd{--es:1;--eu:18;--et:50}&.frame10 .he,&.frame11 .he{--es:1;--eu:18;--et:56}&.frame10 .hg,&.frame11 .hg{--es:1;--eu:19;--et:13}&.frame10 .hh,&.frame11 .hh{--es:1;--eu:19;--et:15}&.frame10 .hi,&.frame11 .hi{--es:1;--eu:19;--et:16}&.frame10 .hj,&.frame11 .hj{--es:1;--eu:19;--et:17}&.frame10 .hk,&.frame11 .hk{--es:1;--eu:19;--et:18}&.frame10 .hl,&.frame11 .hl{--es:1;--eu:19;--et:19}&.frame10 .hm,&.frame11 .hm{--es:1;--eu:19;--et:23}&.frame10 .hn,&.frame11 .hn{--es:1;--eu:19;--et:24}&.frame10 .ho,&.frame11 .ho{--es:1;--eu:19;--et:30}&.frame10 .hp,&.frame11 .hp{--es:1;--eu:19;--et:31}&.frame10 .hq,&.frame11 .hq{--es:1;--eu:19;--et:33}&.frame10 .hr,&.frame11 .hr{--es:1;--eu:19;--et:34}&.frame10 .ht,&.frame11 .ht{--es:1;--eu:20;--et:8}&.frame10 .hu,&.frame11 .hu{--es:1;--eu:20;--et:9}&.frame10 .hv,&.frame11 .hv{--es:1;--eu:21;--et:6}&.frame10 .hw,&.frame11 .hw{--es:1;--eu:21;--et:10}&.frame10 .hx,&.frame11 .hx{--es:1;--eu:22;--et:4}&.frame10 .hy,&.frame11 .hy{--es:1;--eu:22;--et:5}&.frame10 .hz,&.frame11 .hz{--es:1;--eu:23;--et:2}&.frame10 .ia,&.frame11 .ia{--es:1;--eu:24}&.frame10 .ip,&.frame11 .ic{--es:1;--eu:14;--et:14}&.frame10 .iq{--es:1;--eu:14;--et:17}&.frame10 .ir,&.frame11 .if{--es:1;--eu:14;--et:21}&.frame10 .is,&.frame11 .ii{--es:1;--eu:14;--et:28}&.frame11 .ie{--es:1;--eu:14;--et:20}&.frame11 .ij{--es:1;--eu:14;--et:29}&.frame11 .ik{--es:1;--eu:14;--et:31}&.frame11 .il{--es:1;--eu:14;--et:53}&.frame11 .im{--es:1;--eu:14;--et:54}&.frame11 .in{--es:1;--eu:14;--et:60}&.frame11 .io{--es:1;--eu:14;--et:32}&.frame11 .ip{--es:1;--eu:14;--et:34}&.frame11 .iq{--es:1;--eu:14;--et:37}&.frame11 .ir{--es:1;--eu:14;--et:41}&.frame11 .is{--es:1;--eu:14;--et:48}& .iw{left:var(--p);z-index:20;font:var(--j,var(--ev));color:var(--k);text-align:right;width:calc(var(--q)*1ch);-webkit-user-select:none;user-select:none;opacity:var(--es,0);transition:transform var(--e),opacity var(--e);filter:var(--cm-line-numbers-filter,none);position:absolute;overflow:hidden}& .ix{top:calc(var(--o) + 0*var(--b))}& .iy{top:calc(var(--o) + 1*var(--b))}& .iz{top:calc(var(--o) + 2*var(--b))}& .ja{top:calc(var(--o) + 3*var(--b))}& .jb{top:calc(var(--o) + 4*var(--b))}& .jc{top:calc(var(--o) + 5*var(--b))}& .jd{top:calc(var(--o) + 6*var(--b))}& .je{top:calc(var(--o) + 7*var(--b))}& .jf{top:calc(var(--o) + 8*var(--b))}& .jg{top:calc(var(--o) + 9*var(--b))}& .jh{top:calc(var(--o) + 10*var(--b))}& .ji{top:calc(var(--o) + 11*var(--b))}& .jj{top:calc(var(--o) + 12*var(--b))}& .jk{top:calc(var(--o) + 13*var(--b))}& .jl{top:calc(var(--o) + 14*var(--b))}& .jm{top:calc(var(--o) + 15*var(--b))}& .jn{top:calc(var(--o) + 16*var(--b))}& .jo{top:calc(var(--o) + 17*var(--b))}& .jp{top:calc(var(--o) + 18*var(--b))}& .jq{top:calc(var(--o) + 19*var(--b))}& .jr{top:calc(var(--o) + 20*var(--b))}& .js{top:calc(var(--o) + 21*var(--b))}& .jt{top:calc(var(--o) + 22*var(--b))}& .ju{top:calc(var(--o) + 23*var(--b))}& .jv{top:calc(var(--o) + 24*var(--b))}& .jw{white-space:break-spaces;top:var(--r);left:var(--s);z-index:60;color:#0000;font:inherit;margin:0;display:none;position:absolute}&.frame0 .jx,&.frame1 .jy,&.frame2 .jz,&.frame3 .ka,&.frame4 .kb,&.frame5 .kc,&.frame6 .kd,&.frame7 .ke,&.frame8 .kf,&.frame9 .kg,&.frame10 .kh,&.frame11 .ki{display:block}}</style> </code-movie-runtime> <p class="tutorial-controls"> <button class="prev">Previous step</button> <button class="next">Next step</button> </p> <ol class="tutorial-steps"> <li>Start with a regular, vanilla web component class.</li> <li>Model the component's state using class accessors. Alternatively, you could store state in signals or on objects that implement <code>EventTarget</code>.</li> <li>Import the decorator <code>@define()</code> to register your custom element class.</li> <li>Use decorators <code>@attr()</code> and <code>@prop()</code> to define content and IDL attributes respectively. The <code>number()</code>-transformer plugs type-checking into the attributes.</li> <li>Import Preact's functionality. Note that miuch of this can be abstracted away if you choose to write your own base class or micro-framework.</li> <li>Write a method to handle rendering. Can be public, can be private, it's up to you.</li> <li>Time to write some JSX. Don't like JSX? Then just use something else for rendering!</li> <li>Listen for events. You could alternatively leverage event delegation in the component class, if that's more up your alley.</li> <li>Show the current click count. Note that this could just as well be rendered into Shadow DOM if you need more encapsulation.</li> <li>Use the decorator <code>@connected()</code> to run the render method when the component connects to the DOM.</li> <li>Use the decorator <code>@reactive()</code> to run the render method when any attributes change. But since we only really care about <code>#count</code>&nbsp;&hellip;</li> <li>&hellip; we make sure to only render-when something relevant to the method changes. <code>@reactive()</code> has multiple filtering options.</li> </ol> </div> <h2 id="guide">Guide</h2> <aside class="sidebar"> <h3>How is any of this different from anything else?</h3> <p> Ornament is not a framework, but something that you can either build a framework on top of or a tool for building straight web components. Remember: <strong>"Vanilla JavaScript" does not mean that you <em>have</em> to chew on raw vanilla beans 24/7. It's a spectrum! </strong></p> </aside> <h3 id="installation">Installation</h3> <p>Install <a href="https://www.npmjs.com/package/@sirpepe/ornament">@sirpepe/ornament</a> with your favorite package manager. To get the decorator syntax working in 2025, you will probably need <a href="https://babeljs.io/docs/babel-plugin-proposal-decorators">@babel/plugin-proposal-decorators</a> (with option <code>version</code> set to <code>&quot;2023-11&quot;</code>) or <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0/#decorators">TypeScript 5.0+</a> (with the option <code>experimentalDecorators</code> turned <em>off</em>).</p> <p>Apart from that, Ornament is just a bunch of functions. No further setup required.</p> <h3 id="general-philosophy">General philosophy</h3> <p>The native APIs for web components are verbose and imperative, but lend themselves to quite a bit of streamlining with <a href="https://2ality.com/2022/10/javascript-decorators.html">the upcoming syntax for ECMAScript Decorators</a>. The native APIs are also missing a few important primitives. Ornament&#39;s goal is to provide the missing primitives and to streamline the developer experience. Ornament is <strong>not a framework</strong> but instead aims to be:</p> <ul> <li><strong>as stable as possible</strong> by remaining dependency-free, keeping its own code to an absolute minimum, and relying on iron-clad web standards where possible</li> <li><strong>fast and lean</strong> by being nothing more than just a bag of relatively small and simple functions</li> <li>supportive of <strong>gradual</strong> adoption and removal by being able to co-exist with vanilla web component code</li> <li><strong>malleable</strong> by being easy to extend, easy to customize, and easy to get rid of</li> <li><strong>universal</strong> by adhering to (the spirit of) web standards, thereby staying compatible with vanilla web component code as well as all sorts of web frameworks</li> <li>equipped with <strong>useful type definitions</strong> (and work within the constraints of TypeScript)</li> </ul> <p>Ornament is <em>infrastructure for web components</em> and not a framework itself. It makes dealing with the native APIs bearable and leaves building something actually sophisticated up to you. Ornament does not come with <em>any</em> of the following:</p> <ul> <li>state management (even though it is simple to connect components to signals or event targets)</li> <li>rendering (but it works well with <a href="https://github.com/WebReflection/uhtml">uhtml</a>, <a href="https://preactjs.com/">Preact</a> and similar libraries)</li> <li>built-in solutions for client-side routing, data fetching, or anything beyond the components themselves</li> <li>any preconceived notions about what should be going on server-side</li> <li>specialized syntax for every (or any specific) use case</li> </ul> <p>You can (and probably have to) therefore pick or write your own solutions for the above features. Check out the <code>examples</code> folder for inspiration! The examples can be built using <code>npm run build-examples</code>.</p> <h3 id="exit-strategy">Exit strategy</h3> <p>Every good library should come with an exit strategy as well as install instructions. Here is how you can get rid of Ornament if you want to migrate away:</p> <ul> <li>Components built with Ornament will generally turn out to be very close to vanilla web components, so <strong>they will most probably just keep working</strong> when used with other frameworks/libraries. You can theoretically just keep your components and replace them only when the need for change arises. A compatibility wrapper for frameworks that are not quite friendly to web components (eg. React) may be required.</li> <li>If you want to replace Ornament with hand-written logic for web components, you can <strong>replace all attribute and update handling piecemeal.</strong> Ornament&#39;s decorators co-exist with native <code>attributeChangedCallback()</code> and friends just fine. Ornament <em>extends</em> what you can do with custom elements, it does not abstract anything away.</li> <li>Much of your migration will depend on <strong>how you build on top of Ornament.</strong> You should keep reusable components and app-specific state containers separate, just as you would do in e.g. React. This will make maintenance and eventual migration much easier, but this is really outside of Ornament&#39;s area of responsibility.</li> </ul> <p>In general, migrating away should not be too problematic. The components that you will build with Ornament will naturally tend to be self-contained and universal, and will therefore more or less always keep chugging along.</p> <h2 id="decorators">Decorators</h2> <h3 id="api-overview">API overview</h3> <table> <thead> <tr> <th>Decorator</th> <th>Class element</th> <th><code>static</code></th> <th><code>#private</code></th> <th>Symbols</th> <th>Summary</th> </tr> </thead> <tbody><tr> <td><code>@define()</code></td> <td>Class</td> <td>-</td> <td>-</td> <td>-</td> <td>Register a custom element class with a tag name and set it up for use with Ornament&#39;s other decorators</td> </tr> <tr> <td><code>@enhance()</code></td> <td>Class</td> <td>-</td> <td>-</td> <td>-</td> <td>Set up a custom element class for use with Ornament&#39;s other decorators, but do <em>not</em> register it with a tag name</td> </tr> <tr> <td><code>@prop()</code></td> <td>Accessor</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Define an accessor to work as an IDL attribute with a given data type</td> </tr> <tr> <td><code>@attr()</code></td> <td>Accessor</td> <td>âœ•</td> <td>âœ“[^1]</td> <td>âœ“[^1]</td> <td>Define an accessor to work as a content attribute and associated IDL attribute with a given data type</td> </tr> <tr> <td><code>@state()</code></td> <td>Accessor</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“[^2]</td> <td>Track the accessor&#39;s value in the element&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomStateSet">CustomStateSet</a></td> </tr> <tr> <td><code>@reactive()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when accessors decorated with <code>@prop()</code> or <code>@attr()</code> change value (with optional conditions)</td> </tr> <tr> <td><code>@init()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function after the class constructor finishes</td> </tr> <tr> <td><code>@connected()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when the element connects to the DOM</td> </tr> <tr> <td><code>@disconnected()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when the element disconnects from the DOM</td> </tr> <tr> <td><code>@adopted()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when the element is adopted by a new document</td> </tr> <tr> <td><code>@formAssociated()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when the element is associated with a form element</td> </tr> <tr> <td><code>@formReset()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when the element&#39;s form owner resets</td> </tr> <tr> <td><code>@formDisabled()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when the element&#39;s ancestor fieldset is disabled</td> </tr> <tr> <td><code>@formStateRestore()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function when the element&#39;s <code>formStateRestoreCallback</code> fires</td> </tr> <tr> <td><code>@subscribe()</code></td> <td>Accessor, Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Update a reactive accessor or run a method or class field function to react to changes to a signal or to events on an EventTarget</td> </tr> <tr> <td><code>@observe()</code></td> <td>Method, Field[^3]</td> <td>âœ•</td> <td>âœ“</td> <td>âœ“</td> <td>Run a method or class field function as a callback for an IntersectionObserver, MutationObserver, or ResizeObserver</td> </tr> <tr> <td><code>@debounce()</code></td> <td>Method, Field[^3]</td> <td>âœ“</td> <td>âœ“</td> <td>âœ“</td> <td>Debounce a method or class field function, (including <code>static</code>)</td> </tr> </tbody></table> <p>[^1]: Can be <code>#private</code> or a symbol <em>if</em> a non-private non-symbol getter/setter pair for the attribute name exists and a content attribute name has been set using the <code>as</code> option.</p> <p>[^2]: Can be a symbol <em>if</em> a string value has been provided for the state field</p> <p>[^3]: Class field values must be of type <code>function</code></p> <h3 id="definetagname-string-options-elementdefinitionoptions---registry-customelementregistry--windowcustomelements"><code>@define(tagName: string, options: ElementDefinitionOptions = {}, registry: CustomElementRegistry = window.customElements)</code></h3> <p><strong>Class decorator</strong> to register a class as a custom element, basically an alternative syntax for <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/define"><code>customElements.define()</code></a>;</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>)); <span class="hljs-comment">// instance of MyTest</span>
</code></pre><p><code>@define()</code> also sets up attribute observation for use with the <code>@attr()</code> decorator, prepares the hooks for lifecycle decorators like <code>@connected()</code> and ensures that property upgrades for previously undefined elements happen in a predictable fashion. Ornament&#39;s features will only work if the component class is decorated with either <code>@define()</code> or <code>@enhance()</code>.</p> <details> <summary>What are safe upgrades?</summary> <p>HTML tags can be used even if the browser does not (yet) know about them, and this also works with web components - the browser can upgrade custom elements event after the parser has processed them as unknown elements. <a href="https://codepen.io/SirPepe/pen/poqLege?editors=0010">But this can lead to unexpected behavior</a> when properties are set on elements that have not yet been properly defined, shadowing relevant accessors on the prototype:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> x = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;hello-world&quot;</span>);
<span class="hljs-comment">// &quot;x&quot; = unknown element = object with &quot;HTMLElement.prototype&quot; as prototype</span>

x.<span class="hljs-property">data</span> = <span class="hljs-number">42</span>;
<span class="hljs-comment">// &quot;x&quot; now has an _own_ property data=42</span>

<span class="hljs-comment">// Implements an accessor for hello-world. The getters and</span>
<span class="hljs-comment">// setters end up as properties on the prototype</span>
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  accessor data = <span class="hljs-number">23</span>;
}

<span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;hello-world&quot;</span>, <span class="class_ hljs-title">HelloWorld</span>);
<span class="hljs-comment">// It is now clear that &quot;x&quot; should have had &quot;HelloWorld.prototype&quot; as its</span>
<span class="hljs-comment">// prototype all along</span>

<span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="function_ hljs-title">upgrade</span>(x);
<span class="hljs-comment">// &quot;x&quot; now gets &quot;HelloWorld.prototype&quot; as its prototype (with the accessor)</span>

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(x.<span class="hljs-property">data</span>);
<span class="hljs-comment">// logs 42, bypassing the getter - &quot;x&quot; itself has an own property &quot;data&quot;, the</span>
<span class="hljs-comment">// accessor on the prototype is shadowed</span>
</code></pre><p>Ornament ensures safe upgrades, always making sure that no prototype accessors for attributes are ever shadowed by properties defined before an element was properly upgraded.</p> </details> <details> <summary>Notes for TypeScript</summary> <p>You should add your custom element&#39;s interface to <code>HTMLElementTagNameMap</code> to make it work with native DOM APIs:</p> <pre><code class="hljs language-typescript"><span class="hljs-meta">@define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  foo = <span class="hljs-number">1</span>;
}

<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> {
  <span class="hljs-keyword">interface</span> <span class="class_ hljs-title">HTMLElementTagNameMap</span> {
    <span class="hljs-string">&quot;my-test&quot;</span>: <span class="class_ hljs-title">MyTest</span>;
  }
}

<span class="hljs-keyword">let</span> test = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(test.<span class="hljs-property">foo</span>); <span class="hljs-comment">// only type checks with the above interface declaration</span>
</code></pre></details> <p>If you want to run your component code in a non-browser environment like JSDOM, you can pass the JSDOM&#39;s CustomElementRegistry as the third argument to <code>@define()</code>.</p> <h3 id="enhance"><code>@enhance()</code></h3> <p><strong>Class decorator</strong> to set up attribute observation and lifecycle hooks <em>without</em> registering the class as a custom element.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { enhance } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">enhance</span>()
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}

<span class="hljs-comment">// MyTest can only be instantiated when it has been registered as a custom</span>
<span class="hljs-comment">// element. Because we use @enhance() instead of @define() in this example, we</span>
<span class="hljs-comment">// have to take care of this manually.</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>, <span class="class_ hljs-title">MyTest</span>);

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>)); <span class="hljs-comment">// instance of MyTest</span>
</code></pre><p>This decorator is only really useful if you need to handle element registration in some other way than what <code>@define()</code> provides. It is safe to apply <code>@enhance()</code> more than once on a class, or on both (or either) a base class and subclass:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { enhance } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// Not useful, but also not a problem</span>
@<span class="function_ hljs-title">enhance</span>()
@<span class="function_ hljs-title">enhance</span>()
@<span class="function_ hljs-title">enhance</span>()
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest0</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}

<span class="hljs-comment">// Works</span>
@<span class="function_ hljs-title">enhance</span>()
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Base1</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest1</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">Base1</span> {}

<span class="hljs-comment">// Works</span>
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Base2</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}
@<span class="function_ hljs-title">enhance</span>()
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest2</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">Base2</span> {}

<span class="hljs-comment">// Works</span>
@<span class="function_ hljs-title">enhance</span>()
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Base3</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}
@<span class="function_ hljs-title">enhance</span>()
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest3</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">Base3</span> {}
</code></pre><p>Remember that Ornament&#39;s features will only work if the component class is decorated with either <code>@define()</code> or <code>@enhance()</code>.</p> <h3 id="proptransformer-transformerany-any"><code>@prop(transformer: Transformer&lt;any, any&gt;)</code></h3> <p><strong>Accessor decorator</strong> to define an IDL property on the custom element class <em>without</em> an associated content attribute. Such a property is more or less a regular accessor with two additional features:</p> <ul> <li>it uses <strong>transformers</strong> for type checking and validation</li> <li>changes cause class members decorated with <code>@reactive()</code> to run</li> </ul> <p>Example:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, prop, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Applies the number transformer to ensure that foo is always a number</span>
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">number</span>()) accessor foo = <span class="hljs-number">23</span>;

  <span class="hljs-comment">// Automatically runs when &quot;foo&quot; (or any accessor decorated with @prop() or</span>
  <span class="hljs-comment">// @attr()) changes</span>
  @<span class="function_ hljs-title">reactive</span>()
  <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">`Foo changed to <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.foo}</span>`</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// logs 23</span>
testEl.<span class="hljs-property">foo</span> = <span class="hljs-number">42</span>; <span class="hljs-comment">// logs &quot;Foo changed to 42&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// logs 42</span>
testEl.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;asdf&quot;</span>; <span class="hljs-comment">// throw exception (thanks to the number transformer)</span>
</code></pre><p>Accessors defined with <code>@prop()</code> work as a <em>JavaScript-only API</em>. Values can only be accessed through the accessor&#39;s getter, invalid values are rejected by the setter with exceptions. <code>@prop()</code> can be used on private accessors or symbols without problem.</p> <p>Note that you can still define your own accessors, getters, setters etc. as you would usually do. They will still work as expected, but they will not cause <code>@reactive()</code> methods to run.</p> <h3 id="attrtransformer-transformerany-any-options-attroptions--"><code>@attr(transformer: Transformer&lt;any, any&gt;, options: AttrOptions = {})</code></h3> <p><strong>Accessor decorator</strong> to define an IDL attribute with a matching content attribute on the custom element class. This results in something very similar to accessors decorated with <code>@prop()</code>, but with the following additional features:</p> <ul> <li>Its value can be initialized from a content attribute, if the attribute is present</li> <li>Changes to the content attribute&#39;s value (eg. via <code>setAttribute()</code>) update the value of the IDL attribute to match (depending on the options and the transformer)</li> </ul> <details> <summary>What's the deal with content attributes?</summary> <p>Getting attribute handling on Web Components right is <em>hard</em>, because many different APIs and states need to interact in just the right way and the related code tends to end up scattered across various class members. Attributes on HTML elements have two faces: the <em>content attribute</em> and the <em>IDL attribute</em>. Content attributes are always strings and are defined either via HTML or via DOM methods like <code>setAttribute()</code>. IDL attributes can be accessed via object properties such as <code>someElement.foo</code> and may be of any type. Both faces of attributes need to be implemented and properly synced up for an element to be truly compatible with any software out there - a JS frontend framework may work primarily with IDL attributes, while HTML authors or server-side rendering software will work with content attributes.</p> <p>Keeping content and IDL attributes in sync can entail any or all of the following tasks:</p> <ul> <li>Updating the content attribute when the IDL attribute gets changed (eg. update the HTML attribute <code>id</code> when running <code>element.id = &quot;foo&quot;</code> in JS)</li> <li>Updating the IDL attribute when the content attribute gets changed (eg. <code>element.id</code> should return <code>&quot;bar&quot;</code> after <code>element.setAttribute(&quot;id&quot;, &quot;bar&quot;)</code>)</li> <li>Converting types while updating content and/or IDL attributes (an attribute may be a <code>number</code> as an IDL attribute, but content attributes are by definition always strings)</li> <li>Rejecting invalid types on the IDL setter (as opposed to converting types from content to IDL attributes which, like all of HTML, never throws an error)</li> <li>Connecting IDL and content attributes with different names (like how the content attribute <code>class</code> maps to the IDL attribute <code>className</code>)</li> <li>Fine-tuning the synchronization behavior depending on circumstances (see the interaction between the <code>value</code> content and IDL attributes on <code>&lt;input&gt;</code>)</li> <li>Remembering to execute side effects (like updating Shadow DOM) when any IDL and/or content attribute changes</li> </ul> <p>This is all <em>very</em> annoying to write by hand, but because the above behavior is more or less the same for all attributes, it is possible to to simplify the syntax quite a bit:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { attr, define number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">MyTest</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>({ <span class="hljs-attr">min</span>: -<span class="hljs-number">100</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">100</span> })) accessor value = <span class="hljs-number">0</span>;

  @<span class="function_ hljs-title">reactive</span>()
  <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
  }
}
</code></pre><p>The line starting with with <code>@attr</code> gets you a content and a matching IDL attribute named <code>value</code>, which...</p> <ul> <li>Always reflects a number between <code>-100</code> and <code>100</code></li> <li>Initializes from the content attribute and falls back to the initializer value <code>0</code> if the attribute is missing or can&#39;t be interpreted as a number</li> <li>Automatically updates the content attribute with the stringified value of the IDL attribute when the IDL attribute is updated</li> <li>Automatically updates the IDL attribute when the content attribute is updated (it parses the attribute value into a number and clamps it to the specified range)</li> <li>Implements getters and setters for the IDL attributes, with the getter always returning a number and the setter rejecting invalid values (non-numbers or numbers outside the specified range of <code>[-100, 100]</code>)</li> <li>Causes the method marked <code>@reactive()</code> to run on update</li> </ul> <p>You can use <code>@prop()</code> for standalone IDL attribute (that is, DOM properties without an associated content attributes), swap out the <code>number()</code> transformer for something else, or combine any of the above with hand-written logic.</p> </details> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Applies the number transformer to ensure that content attribute values get</span>
  <span class="hljs-comment">// parsed into numbers and that new non-number values passed to the IDL</span>
  <span class="hljs-comment">// attribute&#x27;s setter get rejected</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>()) accessor foo = <span class="hljs-number">23</span>; <span class="hljs-comment">// 23 = fallback value</span>

  <span class="hljs-comment">// Automatically runs when &quot;foo&quot;, or any accessor decorated with @prop() or</span>
  <span class="hljs-comment">// @attr(), changes (plus once on element initialization)</span>
  @<span class="function_ hljs-title">reactive</span>() <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">`Foo changed to <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.foo}</span>`</span>);
  }
}

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;my-test foo=&quot;42&quot;&gt;&lt;/my-test&gt;`</span>;
<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">querySelector</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// logs 42 (initialized from the attribute)</span>
testEl.<span class="hljs-property">foo</span> = <span class="hljs-number">1337</span>; <span class="hljs-comment">// logs &quot;Foo changed to 1337&quot;</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// logs 1337</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="function_ hljs-title">getAttribute</span>(<span class="hljs-string">&quot;foo&quot;</span>)); <span class="hljs-comment">// logs &quot;1337&quot;</span>
testEl.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;asdf&quot;</span>; <span class="hljs-comment">// throw exception (thanks to the number transformer)</span>
testEl.<span class="function_ hljs-title">setAttribute</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;asdf&quot;</span>); <span class="hljs-comment">// works, content attributes can be any string</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// logs 23 (fallback value)</span>
</code></pre><p>Accessors defined with <code>@attr()</code> work like all other supported attributes on built-in elements. Content attribute values (which are always strings) get parsed by the transformer, which also deals with invalid values in a graceful way (ie without throwing exceptions). Values can also be accessed through the IDL property&#39;s accessor, where invalid values <em>are</em> rejected with exceptions by the setter.</p> <p><code>@attr()</code> can only be used on private accessors or symbols only if the following holds true:</p> <ol> <li>The option <code>as</code> <em>must</em> be set</li> <li>A non-private, non-symbol getter/setter pair for the attribute name defined in the option <code>as</code> <em>must</em> exist on the custom element class</li> </ol> <p>Content attributes always have public IDL attribute APIs, and ornament enforces this. A private/symbol attribute accessor with a manually-provided public facade may be useful if you want to attach some additional logic to the public API (= hand-written getters and setters) while still having the convenience of of using <code>@attr</code> on an <code>accessor</code>.</p> <p>Note that you can still define your own attribute handling with <code>attributeChangedCallback()</code> and <code>static get observedAttributes()</code> as you would usually do. This will keep working work as expected, but changes to such attributes will not cause <code>@reactive()</code> methods to run.</p> <h4 id="options-for-attr">Options for <code>@attr()</code></h4> <ul> <li><strong><code>as</code> (string, optional)</strong>: Sets an attribute name different from the accessor&#39;s name, similar to how the <code>class</code> content attribute works for the <code>className</code> IDL attribute on built-in elements. If <code>as</code> is not set, the content attribute&#39;s name will be equal to the accessor&#39;s name. <code>as</code> is required when the decorator is applied to a symbol or private property.</li> <li><strong><code>reflective</code> (boolean, optional)</strong>: If <code>false</code>, prevents the content attribute from updating when the IDL attribute is updated, similar to how <code>value</code> works on <code>input</code> elements. Defaults to true.</li> </ul> <h3 id="stateoptions-stateoptions--"><code>@state(options: StateOptions = {})</code></h3> <p><strong>Accessor decorator</strong> that tracks the accessor&#39;s value in the element&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomStateSet">CustomStateSet</a>. By default, the state&#39;s name is the decorated member&#39;s name and <code>Boolean</code> is used to decide whether a state should be added or removed from the set.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, state } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">state</span>()
  accessor foo = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Default: tracks the state &quot;foo&quot; by transforming the value with Boolean()</span>

  @<span class="function_ hljs-title">state</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;isOdd&quot;</span>, <span class="hljs-attr">toBoolean</span>: <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> value % <span class="hljs-number">2</span> !== <span class="hljs-number">0</span> })
  accessor bar = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// Custom: tracks &quot;bar&quot; as &quot;isOff&quot; by transforming the value with toBoolean()</span>
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);

<span class="hljs-comment">// Custom state &quot;foo&quot; is not set, since Boolean(0) === false</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="function_ hljs-title">matches</span>(<span class="hljs-string">&quot;:state(foo)&quot;</span>)); <span class="hljs-comment">// &gt; false</span>

<span class="hljs-comment">// Custom state &quot;isOdd&quot; is not set, since (value % 2 !== 0) === false</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="function_ hljs-title">matches</span>(<span class="hljs-string">&quot;:state(isOdd)&quot;</span>)); <span class="hljs-comment">// &gt; false</span>

testEl.<span class="hljs-property">foo</span> = <span class="hljs-number">1</span>;
testEl.<span class="hljs-property">bar</span> = <span class="hljs-number">1</span>;

<span class="hljs-comment">// Custom state &quot;foo&quot; is set, since Boolean(1) === true</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="function_ hljs-title">matches</span>(<span class="hljs-string">&quot;:state(foo)&quot;</span>)); <span class="hljs-comment">// &gt; true</span>

<span class="hljs-comment">// Custom state &quot;isOdd&quot; is set, since (value % 2 !== 0) === true</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="function_ hljs-title">matches</span>(<span class="hljs-string">&quot;:state(isOdd)&quot;</span>)); <span class="hljs-comment">// &gt; true</span>
</code></pre><p>The decorator works with private accessors. If no <code>name</code> option is provided, the custom state name includes the <code>#</code> sign. Use on symbol accessors requires the <code>name</code> option.</p> <p>To properly combine with <code>@prop()</code> and <code>@attr()</code>, <code>@state()</code> should be applied to the accessor last to benefit from the type checking and/or conversion provided from the other decorators:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, state, prop, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">number</span>({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span> })) <span class="hljs-comment">// &lt;- @prop() comes first</span>
  @<span class="function_ hljs-title">state</span>({ <span class="hljs-attr">toBoolean</span>: <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> }) <span class="hljs-comment">// &lt;- @state() comes last</span>
  accessor foo = <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">const</span> testEl = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();
<span class="hljs-comment">// state &quot;foo&quot; is true</span>

testEl.<span class="hljs-property">foo</span> = <span class="hljs-number">1</span>;
<span class="hljs-comment">// state &quot;foo&quot; is false</span>

<span class="hljs-keyword">try</span> {
  testEl.<span class="hljs-property">foo</span> = -<span class="hljs-number">2</span>; <span class="hljs-comment">// &lt;- this fails</span>
} <span class="hljs-keyword">catch</span> {
  <span class="hljs-comment">// state &quot;foo&quot; on el still false; @prop intercepted the set operation</span>
}
</code></pre><h4 id="options-for-state">Options for <code>@state()</code></h4> <ul> <li><strong><code>name</code> (string, optional)</strong>: name of the state in the CustomStateSet. If <code>name</code> is not set, the state&#39;s name will be equal to the accessor&#39;s name. <code>name</code> is required when the decorator is applied to a symbol.</li> <li><strong><code>toBoolean</code> (((value, instance) =&gt; boolean), optional)</strong>: Function to transform the accessor&#39;s value into a boolean, which in turn decides whether a state should be added or removed from the set. Defaults to the <code>Boolean</code> function. Called with <code>this</code> set to the component instance.</li> </ul> <h3 id="reactiveoptions-reactiveoptions--"><code>@reactive(options: ReactiveOptions = {})</code></h3> <p><strong>Method and class field decorator</strong> that runs class members when accessors decorated with <code>@prop()</code> or <code>@attr()</code> change their values:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, reactive, prop, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">number</span>()) accessor foo = <span class="hljs-number">0</span>;
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">number</span>()) accessor bar = <span class="hljs-number">0</span>;

  @<span class="function_ hljs-title">reactive</span>()
  <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">`foo is now <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.foo}</span>, bar is now <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.bar}</span>`</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
testEl.<span class="hljs-property">foo</span> = <span class="hljs-number">1</span>;
testEl.<span class="hljs-property">bar</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">// first logs &quot;foo is now 1, bar is now 0&quot;</span>
<span class="hljs-comment">// then logs &quot;foo is now 1, bar is now 2&quot;</span>
</code></pre><p>Decorated members are called with no arguments. They react to changes to the instances&#39; internal state and should therefore be able to access all relevant data through <code>this</code>. In many cases you may want to apply <code>@reactive()</code> to methods decorated with <code>@debounce()</code> to prevent excessive calls.</p> <p>The <code>predicate</code> and/or <code>keys</code> options can be used to control whether the decorated method or function reacts to an update. For the decorated member to run, the following needs to be true:</p> <ol> <li><code>options.keys</code> must either have been omitted or must contain the IDL or content attribute name that changed</li> <li><code>options.excludeKeys</code> must either have been omitted or must not contain the IDL or content attribute name that changed</li> <li><code>options.predicate</code> must either have been omitted or must return true when called immediately before the function is scheduled to run</li> </ol> <h4 id="options-for-reactive">Options for <code>@reactive()</code></h4> <ul> <li><strong><code>keys</code> (Array&lt;string | symbol&gt;, optional)</strong>: List of attributes (defined by <code>@prop()</code> or <code>@attr()</code>) to monitor. Can include private names and symbols. Defaults to monitoring all content and IDL attributes defined by <code>@prop()</code> or <code>@attr()</code>.</li> <li><strong><code>excludeKeys</code> (Array&lt;string | symbol&gt;, optional)</strong>: List of attributes (defined by <code>@prop()</code> or <code>@attr()</code>) not to monitor. Can include private names and symbols. Defaults to an empty array.</li> <li><strong><code>predicate</code> (Function <code>(this: T, prop: string | symbol, newValue: any, instance: T) =&gt; boolean</code>)</strong>: If provided, controls whether or not the decorated method is called for a given change. Note that this function is not part of the class declaration itself and can therefore <em>not</em> access private fields on <code>instance</code>, but the predicate function gets passed the affected IDL property&#39;s name and new value.</li> </ul> <h3 id="init"><code>@init()</code></h3> <p><strong>Method and class field decorator</strong> that runs class members when the class constructor finishes. This has the same effect as adding method calls to the end of the constructor&#39;s body.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, init } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="function_ hljs-title">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-number">23</span>);
  }

  @<span class="function_ hljs-title">init</span>()
  <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-number">42</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-comment">// first logs 23, then logs 42</span>
</code></pre><p>This decorator is particularly useful if you need to run <code>@reactive()</code> methods once on component initialization.</p> <p>Decorated members are run with no arguments and <em>always</em> right after the constructor finishes, even methods and class field functions decorated with <code>@debounce()</code>.</p> <h3 id="connected"><code>@connected()</code></h3> <p><strong>Method and class field decorator</strong> that runs class members when the component connects to the DOM and the component&#39;s <code>connectedCallback()</code> fires:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, connected } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">connected</span>() <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Connected!&quot;</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="function_ hljs-title">append</span>(testEl);
<span class="hljs-comment">// testEl.log logs &quot;Connected!&quot;</span>
</code></pre><p>Decorated members are run with no arguments. You can also still use the regular <code>connectedCallback()</code>.</p> <h3 id="disconnected"><code>@disconnected()</code></h3> <p><strong>Method and class field decorator</strong> that runs decorated class members when the component disconnects from the DOM and the component&#39;s <code>disconnectedCallback()</code> fires:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, adopted } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">disconnected</span>() <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Disconnected!&quot;</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="function_ hljs-title">append</span>(testEl);
testEl.<span class="function_ hljs-title">remove</span>();
<span class="hljs-comment">// testEl.log logs &quot;Disconnected!&quot;</span>
</code></pre><p>Decorated members are run with no arguments. You can also still use the regular <code>disconnectedCallback()</code>.</p> <h3 id="adopted"><code>@adopted()</code></h3> <p><strong>Method and class field decorator</strong> that runs decorated class members when the component is moved to a new document and the component&#39;s <code>adoptedCallback()</code> fires:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, adopted } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">adopted</span>() <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Adopted!&quot;</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-keyword">const</span> newDocument = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Document</span>();
newDocument.<span class="function_ hljs-title">adoptNode</span>(testEl);
<span class="hljs-comment">// testEl.log logs &quot;Adopted!&quot;</span>
</code></pre><p>Decorated members are run with no arguments. You can also still use the regular <code>adoptedCallback()</code>.</p> <h3 id="formassociated"><code>@formAssociated()</code></h3> <p><strong>Method and class field decorator</strong> that runs decorated class members when a form-associated component&#39;s form owner changes and its <code>formAssociatedCallback()</code> fires:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, formAssociated } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-keyword">static</span> formAssociated = <span class="hljs-literal">true</span>;
  @<span class="function_ hljs-title">formAssociated</span>() <span class="function_ hljs-title">log</span>(<span class="hljs-params">newOwner</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(newOwner); <span class="hljs-comment">// null or HTMLFormElement</span>
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;form&quot;</span>);
form.<span class="function_ hljs-title">append</span>(testEl);
<span class="hljs-comment">// testEl.log logs &quot;form&quot;</span>
</code></pre><p>Decorated members are passed the new form owner (if any) as an argument. You can also still use the regular <code>formAssociatedCallback()</code>.</p> <h3 id="formreset"><code>@formReset()</code></h3> <p><strong>Method and class field decorator</strong> that runs decorated class members when a form-associated component&#39;s form owner resets and its <code>formResetCallback()</code> fires:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, formReset } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-keyword">static</span> formAssociated = <span class="hljs-literal">true</span>;
  @<span class="function_ hljs-title">formReset</span>() <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Reset!&quot;</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;form&quot;</span>);
form.<span class="function_ hljs-title">append</span>(testEl);
form.<span class="function_ hljs-title">reset</span>();
<span class="hljs-comment">// ... some time passes...</span>
<span class="hljs-comment">// testEl.log logs &quot;Reset!&quot;</span>
</code></pre><p>Decorated members are run with no arguments. You can also still use the regular <code>formResetCallback()</code>.</p> <p>Note that form reset events are observably asynchronous, unlike all other lifecycle events. This is due to the form reset algorithm itself being async.</p> <h3 id="formdisabled"><code>@formDisabled()</code></h3> <p><strong>Method and class field decorator</strong> that runs decorated class members when a form-associated component&#39;s fieldset gets disabled and its <code>formDisabledCallback()</code> fires:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, formDisabled } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-keyword">static</span> formAssociated = <span class="hljs-literal">true</span>;
  @<span class="function_ hljs-title">formDisabled</span>() <span class="function_ hljs-title">log</span>(<span class="hljs-params">state</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Disabled via fieldset:&quot;</span>, state); <span class="hljs-comment">// true or false</span>
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
<span class="hljs-keyword">let</span> fieldset = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;fieldset&quot;</span>);
<span class="hljs-keyword">let</span> form = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;form&quot;</span>);
form.<span class="function_ hljs-title">append</span>(fieldset);
fieldset.<span class="function_ hljs-title">append</span>(testEl);
fieldset.<span class="hljs-property">disabled</span> = <span class="hljs-literal">true</span>;
<span class="hljs-comment">// testEl.log logs &quot;Disabled via fieldset: true&quot;</span>
</code></pre><p>Decorated members are passed the new form disabled state as an argument. You can also still use the regular <code>formDisabledCallback()</code>.</p> <h3 id="formstaterestore"><code>@formStateRestore()</code></h3> <p><strong>Method and class field decorator</strong> that causes runs decorated class methods when a form-associated component&#39;s <code>formStateRestoreCallback()</code> fires. This does not work in Chrome-based browsers as of November 2023.</p> <h3 id="subscribeargs"><code>@subscribe(...args)</code></h3> <p><strong>Accessor, method or class field decorator</strong> that subscribes to either <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">Event Targets</a> or <a href="https://github.com/preactjs/signals">signals</a>, depending on the arguments. If the decorated class member is a method or a function, it runs when the EventTarget emits a new event or when the signal receives a new value. If the decorated member is an accessor, it gets updated with the last event object (for event targets) or signal values (for signals). You can decorate the accessor with <code>@prop()</code> to cause methods decorated with <code>@reactive()</code> to run when its value changes.</p> <h4 id="subscribe-to-eventtargets-subscribetargetortargetfactory-eventtarget--instance-t--eventtarget--promiseeventtarget-eventnames-string-options-eventsubscribeoptions--">Subscribe to EventTargets: <code>@subscribe(targetOrTargetFactory: EventTarget | ((instance: T) =&gt; EventTarget) | Promise&lt;EventTarget&gt;, eventNames: string, options: EventSubscribeOptions = {})</code></h4> <p>Subscribe the decorated class member to one or more events an EventTarget. <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget</a> is an interface that objects such as HTMLElement, Window, Document and <em>many</em> more objects implement. You can also create a vanilla event target or extend the <code>EventTarget</code> class:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-keyword">const</span> myTarget = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">EventTarget</span>();

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">subscribe</span>(myTarget, <span class="hljs-string">&quot;foo&quot;</span>)
  <span class="function_ hljs-title">log</span>(<span class="hljs-params">evt</span>) {
    <span class="hljs-comment">// evt = Event({ name: &quot;foo&quot;, target: myTarget })</span>
    <span class="hljs-comment">// this = Test instance</span>
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">`&#x27;<span class="hljs-subst">${evt.type}</span>&#x27; event fired!`</span>);
  }
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);

myTarget.<span class="function_ hljs-title">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="class_ hljs-title">Event</span>(<span class="hljs-string">&quot;foo&quot;</span>));

<span class="hljs-comment">// testEl.log logs &quot;&#x27;foo&#x27; event fired!&quot;</span>
</code></pre><p>To subscribe to multiple events, pass a single string with the event names separated by whitespace:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-keyword">const</span> myTarget = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">EventTarget</span>();

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">subscribe</span>(myTarget, <span class="hljs-string">&quot;foo bar&quot;</span>) #<span class="function_ hljs-title">a</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// subscribed to both &quot;foo&quot; and &quot;bar&quot;</span>
}
</code></pre><p>You can also provide a target-producing factory or promise in place of the target itself:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// &quot;window&quot; is a perfectly valid event target</span>
  @<span class="function_ hljs-title">subscribe</span>(<span class="hljs-variable language_">window</span>, <span class="hljs-string">&quot;update&quot;</span>) #<span class="function_ hljs-title">a</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// same effect as below</span>
  @<span class="function_ hljs-title">subscribe</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">window</span>, <span class="hljs-string">&quot;update&quot;</span>) #<span class="function_ hljs-title">b</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// same effect as above</span>
  @<span class="function_ hljs-title">subscribe</span>(<span class="class_ hljs-title">Promise</span>.<span class="function_ hljs-title">resolve</span>(<span class="hljs-variable language_">window</span>), <span class="hljs-string">&quot;update&quot;</span>) #<span class="function_ hljs-title">c</span>(<span class="hljs-params"></span>) {} <span class="hljs-comment">// same effect as above</span>
}
</code></pre><p>The target-producing factory function can be used to access targets that depend on the element instance, such as the element&#39;s shadow root. The factory function gets called each time an element initializes, with its first argument set to the instance.</p> <details> <summary>Notes for TypeScript</summary> <p>An event target can actually be delivered by an <em>arbitrarily</em> long chain of nested functions and promises. This is annoying to handle on the type level, you&#39;ll just have to <code>any</code> your way around that or provide this capability in a type-safe wrapper.</p> <p>Making the <code>@subscribe()</code> decorator type-safe for use with events is a gnarly prospect. Given an event target and an event name, the decorator <em>can&#39;t</em> know what type of event the method must expect. Therefore the following is possible by default:</p> <pre><code class="hljs language-typescript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-keyword">let</span> target = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);

<span class="hljs-meta">@define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-meta">@subscribe</span>(target, <span class="hljs-string">&quot;click&quot;</span>)
  #<span class="function_ hljs-title">handleClicks</span>(<span class="hljs-params"><span class="hljs-attr">evt</span>: <span class="class_ hljs-title">MouseEvent</span></span>) {} <span class="hljs-comment">// This type checks, as it should</span>

  <span class="hljs-meta">@subscribe</span>(target, <span class="hljs-string">&quot;click&quot;</span>)
  #<span class="function_ hljs-title">handleAnimations</span>(<span class="hljs-params"><span class="hljs-attr">evt</span>: <span class="class_ hljs-title">AnimationEvent</span></span>) {} <span class="hljs-comment">// This type checks too!</span>
}
</code></pre><p>A mapping between event names and corresponding event types (such as <code>&quot;click&quot;</code> â†’ <code>MouseEvent</code>) exists for specific cases. For example <code>HTMLElementEventMap</code> contains the mappings for events emitted by HTML elements. But because <code>@subscribe()</code> can work with <em>any event target</em>, the existence or relevance of such a mapping can&#39;t be assumed. The only way around this is to create an abstraction for specific use cases where such a mapping is available. This can be based on <code>@subscribe()</code> itself:</p> <pre><code class="hljs language-typescript"><span class="hljs-comment">// Create a variant of @subscribe() specific to DOM events</span>
<span class="hljs-keyword">const</span> listen = &lt;
  T <span class="hljs-keyword">extends</span> <span class="class_ hljs-title">HTMLElement</span>,
  K <span class="hljs-keyword">extends</span> keyof <span class="class_ hljs-title">HTMLElementEventMap</span>,
&gt;<span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">source</span>: <span class="class_ hljs-title">HTMLElement</span>,
  ...<span class="hljs-attr">eventNames</span>: K[]
</span>) =&gt;</span>
  subscribe&lt;T, <span class="class_ hljs-title">HTMLElement</span>, <span class="class_ hljs-title">HTMLElementEventMap</span>[K]&gt;(
    source,
    eventNames.<span class="function_ hljs-title">join</span>(<span class="hljs-string">&quot; &quot;</span>),
  );

<span class="hljs-keyword">const</span> eventSource = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;div&quot;</span>);
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Works: &quot;click&quot; is a MouseEvent</span>
  <span class="hljs-meta">@listen</span>(eventSource, <span class="hljs-string">&quot;click&quot;</span>)
  <span class="function_ hljs-title">handleClick</span>(<span class="hljs-params"><span class="hljs-attr">evt</span>: <span class="class_ hljs-title">MouseEvent</span></span>) {}

  <span class="hljs-comment">// Works: all event types listed by name are covered in the union</span>
  <span class="hljs-meta">@listen</span>(eventSource, <span class="hljs-string">&quot;transitionstart&quot;</span>, <span class="hljs-string">&quot;animationstart&quot;</span>)
  <span class="function_ hljs-title">handleAnimationStart</span>(<span class="hljs-params"><span class="hljs-attr">evt</span>: <span class="class_ hljs-title">AnimationEvent</span> | <span class="class_ hljs-title">TransitionEvent</span></span>) {}

  <span class="hljs-comment">// Type error: &quot;focus&quot; is not a mouse event</span>
  <span class="hljs-meta">@listen</span>(eventSource, <span class="hljs-string">&quot;focus&quot;</span>)
  <span class="function_ hljs-title">handleFocus</span>(<span class="hljs-params"><span class="hljs-attr">evt</span>: <span class="class_ hljs-title">MouseEvent</span></span>) {}

  <span class="hljs-comment">// Type error: type &quot;TransitionEvent&quot; is not covered</span>
  <span class="hljs-meta">@listen</span>(eventSource, <span class="hljs-string">&quot;transitionend&quot;</span>, <span class="hljs-string">&quot;animationend&quot;</span>)
  <span class="function_ hljs-title">handleAnimationEnd</span>(<span class="hljs-params"><span class="hljs-attr">evt</span>: <span class="class_ hljs-title">AnimationEvent</span></span>) {}

  <span class="hljs-comment">// Type error: &quot;asdf&quot; is not a DOM event</span>
  <span class="hljs-meta">@listen</span>(eventSource, <span class="hljs-string">&quot;asdf&quot;</span>)
  <span class="function_ hljs-title">handleAsdf</span>(<span class="hljs-params"><span class="hljs-attr">evt</span>: <span class="class_ hljs-title">Event</span></span>) {}
</code></pre></details> <h5 id="options-for-subscribe-for-eventtarget">Options for <code>@subscribe()</code> for EventTarget</h5> <ul> <li><strong><code>targetOrTargetFactory</code> (EventTarget | Promise&lt;EventTarget&gt; | ((instance: T) =&gt; EventTarget) | Promise&lt;EventTarget&gt;)</strong>: The event target (or event-target-returning function/promise) to subscribe to</li> <li><strong><code>eventNames</code> (string)</strong>: The event(s) to listen to. To subscribe to multiple events, pass a single string with the event names separated by whitespace</li> <li><strong><code>options</code> (object, optional)</strong>: Event handling options, consisting of...<ul> <li><strong>predicate (function <code>(this: T, event: Event, instance: T) =&gt; boolean</code>, optional)</strong>: If provided, controls whether or not the decorated method is called for a given event. Gets passed the element instance and the event object, and must return a boolean. Note that this method always handles the raw event object, before and eventual <code>transform()</code> is applied.</li> <li><strong>transform (function <code>&lt;U&gt;(this: T, event: Event, instance: T) =&gt; U</code>, optional)</strong>: If provided, transforms the event object into something else. The decorated class element must be compatible with the type returned from <code>transform()</code>.</li> <li><strong>activateOn (Array&lt;string&gt;, optional):</strong> Ornament event on which to activate the subscription (that is, when to actually start listening on the EventTarget). Defaults to <code>[&quot;init&quot;, &quot;connected&quot;]</code>.</li> <li><strong>deactivateOn (Array&lt;string&gt;, optional):</strong> Ornament event on which to deactivate the subscription (when to call <code>removeEventListener()</code> on the EventTarget). Defaults to <code>[&quot;disconnected&quot;]</code>.</li> <li><strong>capture (boolean, optional):</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters">option for <code>addEventListener()</code></a></li> <li><strong>once (boolean, optional):</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters">option for <code>addEventListener()</code></a></li> <li><strong>passive (boolean, optional):</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters">option for <code>addEventListener()</code></a></li> <li><strong>signal (AbortSignal, optional):</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#parameters">option for <code>addEventListener()</code></a></li> </ul> </li> </ul> <h4 id="subscribe-to-signals-subscribesignal-signallikeany-options-signalsubscribeoptions--">Subscribe to Signals: <code>@subscribe(signal: SignalLike&lt;any&gt;, options: SignalSubscribeOptions = {})</code></h4> <p>Subscribe to a signal:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;
<span class="hljs-keyword">import</span> { signal } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@preact/signals-core&quot;</span>;

<span class="hljs-keyword">const</span> counter = <span class="function_ hljs-title">signal</span>(<span class="hljs-number">0</span>);
@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">subscribe</span>(counter)
  <span class="function_ hljs-title">test</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(counter.<span class="hljs-property">value</span>);
  }
}
<span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();
counter.<span class="hljs-property">value</span> = <span class="hljs-number">1</span>;
counter.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;
counter.<span class="hljs-property">value</span> = <span class="hljs-number">3</span>;
<span class="hljs-comment">// logs 0, 1, 2, 3</span>
</code></pre><p>Any signal object that implements the following API should work:</p> <pre><code class="hljs language-typescript"><span class="hljs-keyword">type</span> <span class="class_ hljs-title">Signal</span>&lt;T&gt; = {
  <span class="hljs-comment">// Takes an update callback and returns an unsubscribe function</span>
  <span class="function_ hljs-title">subscribe</span>(<span class="hljs-attr">callback</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>): <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-comment">// Represents the current value</span>
  <span class="hljs-attr">value</span>: T;
};
</code></pre><p>Because signals permanently represent reactive values, subscribing itself causes the method to be called with the then-current signal value. This is in contrast to subscribing to Event Targets, which do not represent values, but just happen to throw events around.</p> <h5 id="options-for-subscribe-for-signals">Options for <code>@subscribe()</code> for signals</h5> <ul> <li><strong><code>signal</code> (Signal)</strong>: The signal to subscribe to</li> <li><strong><code>options</code> (object, optional)</strong>: Update handling options, consisting of...<ul> <li><strong>predicate (function <code>(this: T, value, instance: T) =&gt; boolean</code>, optional)</strong>: If provided, controls whether or not the decorated method is called for a given signal update. Gets passed the element instance and the signal&#39;s value, and must return a boolean. Note that this method always handles the raw signal value, before and eventual <code>transform()</code> is applied.</li> <li><strong>transform (function <code>&lt;U&gt;(this: T, value, instance: T) =&gt; U</code>, optional)</strong>: If provided, transforms the signal value into something else. The decorated class element must be compatible with the type returned from <code>transform()</code>.</li> <li><strong>activateOn (Array&lt;string&gt;, optional):</strong> Ornament event on which to activate the subscription (that is, when to actually subscribe to the Signal). Defaults to <code>[&quot;init&quot;, &quot;connected&quot;]</code>.</li> <li><strong>deactivateOn (Array&lt;string&gt;, optional):</strong> Ornament event on which to unsubscribe from the signal. Defaults to <code>[&quot;disconnected&quot;]</code>.</li> </ul> </li> </ul> <h3 id="debounceoptions-debounceoptions--"><code>@debounce(options: DebounceOptions = {})</code></h3> <p><strong>Method and class field decorator</strong> for debouncing method/function invocation:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, debounce } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Debounce a class method</span>
  @<span class="function_ hljs-title">debounce</span>()
  <span class="function_ hljs-title">test1</span>(<span class="hljs-params">x</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(x);
  }
  <span class="hljs-comment">// Debounce a class field function</span>
  @<span class="function_ hljs-title">debounce</span>() test2 = <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(x);
}

<span class="hljs-keyword">const</span> el = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();

el.<span class="function_ hljs-title">test1</span>(<span class="hljs-number">1</span>);
el.<span class="function_ hljs-title">test1</span>(<span class="hljs-number">2</span>);
el.<span class="function_ hljs-title">test1</span>(<span class="hljs-number">3</span>);
<span class="hljs-comment">// only logs &quot;3&quot;</span>

el.<span class="function_ hljs-title">test2</span>(<span class="hljs-string">&quot;a&quot;</span>);
el.<span class="function_ hljs-title">test2</span>(<span class="hljs-string">&quot;b&quot;</span>);
el.<span class="function_ hljs-title">test2</span>(<span class="hljs-string">&quot;c&quot;</span>);
<span class="hljs-comment">// only logs &quot;c&quot;</span>
</code></pre><p><code>@debounce()</code> works with class methods, static methods, and class field functions.</p> <details> <summary>Notes for TypeScript</summary> <p>Debouncing a method or class field function makes it impossible for the method or function to return anything but <code>undefined</code>. TypeScript does currently not allow decorators to modify its target&#39;s type, so <code>@debounce()</code> can&#39;t do that. If you apply <code>@debounce()</code> to a method <code>(x: number) =&gt; number</code>, TypeScript will keep using this signature, even though the decorated method will no longer be able to return anything but <code>undefined</code>.</p> </details> <h4 id="options-for-debounce">Options for <code>@debounce()</code></h4> <ul> <li><strong><code>fn</code> (function, optional)</strong>: The debounce function to use. Defaults to <code>debounce.raf()</code>. The following debounce functions are available:<ul> <li><code>debounce.raf()</code>: uses <code>requestAnimationFrame()</code></li> <li><code>debounce.timeout(ms: number)</code>: uses <code>setTimeout()</code></li> <li><code>debounce.asap()</code>: runs the function after the next microtask</li> </ul> </li> </ul> <h3 id="observector-observerconstructor-options-observeroptions--"><code>@observe(ctor: ObserverConstructor, options: ObserverOptions = {})</code></h3> <p><strong>Method and class field decorator</strong> that sets up a <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver">MutationObserver</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver">ResizeObserver</a>, or <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API">IntersectionObserver</a> with the element instance as the target and the decorated method as the callback. This enables the component to observe itself:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, observe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Pass the observer constructor and relevant options</span>
  @<span class="function_ hljs-title">observe</span>(<span class="class_ hljs-title">MutationObserver</span>, { <span class="hljs-attr">childList</span>: <span class="hljs-literal">true</span> })
  <span class="function_ hljs-title">reactToChanges</span>(<span class="hljs-params">mutations, observer</span>) {
    <span class="hljs-comment">// &quot;mutations&quot; = array of MutationRecord objects</span>
    <span class="hljs-comment">// &quot;observer&quot; = the observer instance</span>
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(mutations);
  }
}

<span class="hljs-keyword">const</span> el = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();
el.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;Test&quot;</span>; <span class="hljs-comment">// cause mutation</span>

<span class="hljs-comment">// Test.reactToChanges() gets called asynchronously by the observer</span>
</code></pre><p><code>@observe()</code> always observes the element that the decorated method belongs to and its reactions are always observably (heh) asynchronous. The decorator does little more than create an observer object with the options provided and the decorated method as the callback function. In theory this should work with every kind of DOM-related observer, but has only been tested with MutationObserver, ResizeObserver and IntersectionObserver so far.</p> <h4 id="options-for-observe">Options for <code>@observe()</code></h4> <ul> <li><strong><code>Ctor</code> (function)</strong>: The observer constructor function (probably one of <code>MutationObserver</code>, <code>ResizeObserver</code>, and <code>IntersectionObserver</code>)</li> <li><strong><code>options</code> (object, optional)</strong>: A mixin type consisting of<ul> <li>All options for the relevant observer type (see MDN for options for <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/observe#options">MutationObserver</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver/IntersectionObserver#options">ResizeObserver</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe#options">IntersectionObserver</a>)</li> <li><strong><code>predicate</code> (function <code>(instance: T, records, observer) =&gt; boolean</code>)</strong>: If provided, controls whether or not an observer callback invocation calls the decorated method. Gets passed the observer&#39;s callback arguments (an array of records and the observer object) as well as the element instance and must return a boolean.</li> <li><strong>activateOn (Array&lt;string&gt;, optional):</strong> Ornament event on which to start observing the element. Defaults to <code>[&quot;init&quot;, &quot;connected&quot;]</code>.</li> <li><strong>deactivateOn (Array&lt;string&gt;, optional):</strong> Ornament event on which to stop observing the element. Defaults to <code>[&quot;disconnected&quot;]</code>.</li> </ul> </li> </ul> <h2 id="transformers">Transformers</h2> <p>Transformers define how the accessor decorators <code>@attr()</code> and <code>@prop()</code> implement attribute handling and type transformations. This includes converting content attributes from and to IDL attributes, type checks on IDL setters, and running side effects.</p> <h3 id="transformers-overview">Transformers overview</h3> <table> <thead> <tr> <th>Transformer</th> <th>Type</th> <th>Options</th> </tr> </thead> <tbody><tr> <td><code>string()</code></td> <td><code>string</code></td> <td></td> </tr> <tr> <td><code>href()</code></td> <td><code>string</code> (URL)</td> <td><code>location</code></td> </tr> <tr> <td><code>bool()</code></td> <td><code>boolean</code></td> <td></td> </tr> <tr> <td><code>number()</code></td> <td><code>number</code></td> <td><code>min</code>, <code>max</code>, <code>allowNaN</code>, <code>nullable</code></td> </tr> <tr> <td><code>int()</code></td> <td><code>bigint</code></td> <td><code>min</code>, <code>max</code>, <code>nullable</code></td> </tr> <tr> <td><code>json()</code></td> <td>Any (JSON serializable for use with <code>@attr()</code>)</td> <td><code>reviver</code>, <code>replacer</code></td> </tr> <tr> <td><code>list()</code></td> <td>Array</td> <td><code>separator</code>, <code>transform</code></td> </tr> <tr> <td><code>literal()</code></td> <td>Any</td> <td><code>values</code>, <code>transform</code></td> </tr> <tr> <td><code>any()</code></td> <td><code>any</code></td> <td></td> </tr> <tr> <td><code>event()</code></td> <td><code>function | null</code></td> <td></td> </tr> </tbody></table> <p>A transformer is just a bag of functions with the following type signature:</p> <pre><code class="hljs language-typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> <span class="class_ hljs-title">Transformer</span>&lt;
  T <span class="hljs-keyword">extends</span> <span class="class_ hljs-title">HTMLElement</span>,
  <span class="class_ hljs-title">Value</span>,
  <span class="class_ hljs-title">IntermediateValue</span> = <span class="class_ hljs-title">Value</span>,
&gt; = {
  <span class="hljs-comment">// Validates and/or transforms a value before it is used to initialize the</span>
  <span class="hljs-comment">// accessor. Can also be used to run a side effect when the accessor</span>
  <span class="hljs-comment">// initializes. Defaults to the identity function.</span>
  <span class="hljs-attr">init</span>: <span class="hljs-function">(<span class="hljs-params">
    <span class="hljs-attr">this</span>: T,
    <span class="hljs-attr">value</span>: <span class="class_ hljs-title">Value</span>,
    <span class="hljs-attr">context</span>: <span class="class_ hljs-title">ClassAccessorDecoratorContext</span>&lt;T, <span class="class_ hljs-title">Value</span>&gt;,
    <span class="hljs-attr">isContentAttribute</span>: <span class="hljs-built_in">boolean</span>,
  </span>) =&gt;</span> <span class="class_ hljs-title">Value</span>;
  <span class="hljs-comment">// Turns content attribute values into IDL attribute values. Must never throw</span>
  <span class="hljs-comment">// exceptions, and instead always just deal with its input. Must not cause any</span>
  <span class="hljs-comment">// observable side effects. May return NO_VALUE in case the content attribute</span>
  <span class="hljs-comment">// can&#x27;t be parsed, in which case the @attr() decorator must not change the</span>
  <span class="hljs-comment">// IDL attribute value</span>
  <span class="hljs-attr">parse</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">this</span>: T, <span class="hljs-attr">value</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) =&gt;</span> <span class="class_ hljs-title">Value</span> | <span class="hljs-keyword">typeof</span> <span class="constant_ hljs-variable">NO_VALUE</span>;
  <span class="hljs-comment">// Decides if setter inputs, which may be of absolutely any type, should be</span>
  <span class="hljs-comment">// accepted or rejected. Should throw for invalid values, just like setters on</span>
  <span class="hljs-comment">// built-in elements may. Must not cause any observable side effects.</span>
  <span class="hljs-attr">validate</span>: <span class="hljs-function">(<span class="hljs-params">
    <span class="hljs-attr">this</span>: T,
    <span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span>,
    <span class="hljs-attr">isContentAttribute</span>: <span class="hljs-built_in">boolean</span>,
  </span>) =&gt;</span> asserts value is <span class="class_ hljs-title">IntermediateValue</span>;
  <span class="hljs-comment">// Transforms values that were accepted by validate() into the proper type by</span>
  <span class="hljs-comment">// eg. clamping numbers, normalizing strings etc.</span>
  <span class="hljs-attr">transform</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">this</span>: T, <span class="hljs-attr">value</span>: <span class="class_ hljs-title">IntermediateValue</span></span>) =&gt;</span> <span class="class_ hljs-title">Value</span>;
  <span class="hljs-comment">// Turns IDL attribute values into content attribute values (strings), thereby</span>
  <span class="hljs-comment">// controlling the attribute representation of an accessor together with</span>
  <span class="hljs-comment">// updateContentAttr(). Must never throw, defaults to the String() function</span>
  <span class="hljs-attr">stringify</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">this</span>: T, <span class="hljs-attr">value</span>: <span class="class_ hljs-title">Value</span></span>) =&gt;</span> <span class="hljs-built_in">string</span>;
  <span class="hljs-comment">// Determines whether a new attribute value is equal to the old value. If this</span>
  <span class="hljs-comment">// method returns true, reactive callbacks will not be triggered. Defaults to</span>
  <span class="hljs-comment">// simple strict equality (===).</span>
  <span class="hljs-attr">eql</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">this</span>: T, <span class="hljs-attr">a</span>: <span class="class_ hljs-title">Value</span>, <span class="hljs-attr">b</span>: <span class="class_ hljs-title">Value</span></span>) =&gt;</span> <span class="hljs-built_in">boolean</span>;
  <span class="hljs-comment">// Optionally run a side effect immediately before the accessor&#x27;s setter is</span>
  <span class="hljs-comment">// invoked. Required by the event transformer.</span>
  <span class="hljs-attr">beforeSet</span>: <span class="hljs-function">(<span class="hljs-params">
    <span class="hljs-attr">this</span>: T,
    <span class="hljs-attr">value</span>: <span class="class_ hljs-title">Value</span>,
    <span class="hljs-attr">context</span>: <span class="class_ hljs-title">ClassAccessorDecoratorContext</span>&lt;T, <span class="class_ hljs-title">Value</span>&gt;,
    <span class="hljs-attr">attributeRemoved</span>: <span class="hljs-built_in">boolean</span>,
  </span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-comment">// Optionally transform the getter&#x27;s response. Required by the href</span>
  <span class="hljs-comment">// transformer.</span>
  <span class="hljs-attr">transformGet</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">this</span>: T, <span class="hljs-attr">value</span>: <span class="class_ hljs-title">Value</span></span>) =&gt;</span> <span class="class_ hljs-title">Value</span>;
  <span class="hljs-comment">// Decides if, based on a new value, an attribute gets updated to match the</span>
  <span class="hljs-comment">// new value (true/false) or removed (null). Only gets called when the</span>
  <span class="hljs-comment">// transformer&#x27;s eql() method returns false. Defaults to a function that</span>
  <span class="hljs-comment">// always returns true.</span>
  <span class="hljs-attr">updateContentAttr</span>: <span class="hljs-function">(<span class="hljs-params">
    <span class="hljs-attr">oldValue</span>: <span class="class_ hljs-title">Value</span> | <span class="hljs-literal">null</span>,
    <span class="hljs-attr">newValue</span>: <span class="class_ hljs-title">Value</span> | <span class="hljs-literal">null</span>,
  </span>) =&gt;</span> <span class="hljs-built_in">boolean</span> | <span class="hljs-literal">null</span>;
};
</code></pre><p>Because transformers need to potentially do a lot of type juggling and bookkeeping, they are somewhat tricky to get right, but they are also always only a few self-contained lines of code. If you want to extend Ornament, you should simply clone one of the built-in transformers and modify it to your liking.</p> <h3 id="notes-for-all-transformers">Notes for all transformers</h3> <h4 id="for-use-with-both-prop-and-attr">For use with both <code>@prop()</code> and <code>@attr()</code></h4> <p>In principle all transformers can be used with both <code>@prop()</code> and <code>@attr()</code>. Very few transformers are limited to use with either decorator, such as <code>event()</code> (which makes very little sense outside of content attributes).</p> <p>The accessor&#39;s initial value serves as fallback value in case no other data is available (eg. when a content attribute gets removed). Transformers validate their initial value and most transformers contain reasonable default values (<code>&quot;&quot;</code> for <code>string()</code>, <code>0</code> for <code>number()</code> etc.).</p> <h4 id="for-use-with-attr">For use with <code>@attr()</code></h4> <p>A content attribute&#39;s IDL attribute value can be unset to the accessor&#39;s initial value by removing a previously set content attribute:</p> <p>As an example:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, string } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>()) accessor foo = <span class="hljs-string">&quot;default value&quot;</span>;
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>()) accessor bar = <span class="hljs-string">&quot;default value&quot;</span>;
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>()) accessor baz;
}

<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerHTML</span> += <span class="hljs-string">`&lt;my-test foo=&quot;other value&quot;&gt;&lt;/my-test&gt;`</span>;
</code></pre><p>The attributes <code>foo</code>, <code>bar</code> and <code>baz</code> behave as follows:</p> <ul> <li>The element initializes with a content attribute <strong><code>foo</code></strong> already set in HTML. The IDL attribute <code>foo</code> will therefore (because it uses the string type via the <code>string()</code> transformer) contain <code>&quot;other value&quot;</code>. Should the content attribute <code>foo</code> get removed, the IDL attribute will contain <code>&quot;default value&quot;</code>.</li> <li>The content attribute <strong><code>bar</code></strong> is not set in HTML, which will result in the IDL attribute <code>bar</code> containing the accessor&#39;s default value <code>&quot;default value&quot;</code>.</li> <li>The content attribute <strong><code>baz</code></strong> is also not set in HTML <em>and</em> the accessor has no initial value, so the <code>string()</code> transformer&#39;s built-in fallback value <code>&quot;&quot;</code> gets used.</li> </ul> <h3 id="transformer-string">Transformer <code>string()</code></h3> <p>Implements a string attribute or property. Modeled after built-in string attributes such as <code>id</code> and <code>lang</code>, it will always represent a string and stringify any and all non-string values.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, string } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>()) accessor foo = <span class="hljs-string">&quot;default value&quot;</span>;
}
</code></pre><h4 id="behavior-overview-for-transformer-string">Behavior overview for transformer <code>string()</code></h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute (when used with <code>@attr()</code>)</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute to <code>x</code></td> <td><code>String(x)</code></td> <td>IDL attribute value</td> </tr> <tr> <td>Set content attribute</td> <td>Content attribute value</td> <td>As set (equal to IDL attribute value)</td> </tr> <tr> <td>Remove content attribute</td> <td>Initial value or <code>&quot;&quot;</code></td> <td>Removed</td> </tr> </tbody></table> <h3 id="transformer-href-location--windowlocation---location-location---">Transformer <code>href({ location = window.location }: { location?: Location } = {})</code></h3> <p>Implements a string attribute or property that works exactly like the <code>href</code> attribute on <code>&lt;a&gt;</code> in that it automatically turns relative URLs into absolute URLs.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, href } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">href</span>()) accessor foo = <span class="hljs-string">&quot;&quot;</span>;
}

<span class="hljs-keyword">let</span> testEl = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();

<span class="hljs-comment">// Assuming that the page is served from localhost:</span>
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &gt; &quot;&quot;</span>
testEl.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;asdf&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &gt; &quot;http://localhost/asdf&quot;</span>
testEl.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;https://example.com/foo/bar/&quot;</span>;
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(testEl.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &gt; &quot;https://example.com/foo/bar/&quot;</span>
</code></pre><p>If you want to run your component code in a non-browser environment like JSDOM, you can pass the JSDOM&#39;s <code>window.location</code> as the option <code>location</code>.</p> <h4 id="behavior-overview-for-transformer-href">Behavior overview for transformer <code>href()</code></h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute (when used with <code>@attr()</code>)</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute to absolute URL (string)</td> <td>Absolute URL</td> <td>IDL attribute value</td> </tr> <tr> <td>Set IDL attribute to any other value <code>x</code></td> <td>Relative URL to <code>String(x)</code></td> <td>IDL attribute value</td> </tr> <tr> <td>Set content attribute to absolute URL (string)</td> <td>Absolute URL</td> <td>As set</td> </tr> <tr> <td>Set content attribute to any other string <code>x</code></td> <td>Relative URL to <code>x</code></td> <td>As set</td> </tr> <tr> <td>Remove content attribute</td> <td>Initial value or <code>&quot;&quot;</code></td> <td>Removed</td> </tr> </tbody></table> <h3 id="transformer-numberoptions-numberoptions--">Transformer <code>number(options: NumberOptions = {})</code></h3> <p>Implements a number attribute with optional range constraints.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// With default options (see below)</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>()) accessor foo = <span class="hljs-number">0</span>;

  <span class="hljs-comment">// With all options set</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">10</span> })) accessor bar = <span class="hljs-number">0</span>;
}
</code></pre><p>Non-numbers get converted to numbers. The transformer allows <code>null</code> and <code>undefined</code> (with the latter converting to <code>null</code>) if the option <code>nullable</code> is set to <code>true</code>. If converting a non-number to a number results in <code>NaN</code> and the option <code>allowNaN</code> is not set to <code>true</code>, the property setter and the accessor&#39;s initializer throw exceptions.</p> <h4 id="options-for-transformer-number">Options for transformer <code>number()</code></h4> <ul> <li><strong><code>min</code> (number, optional)</strong>: Smallest possible value. Defaults to <code>-Infinity</code>. Content attribute values less than <code>min</code> get clamped, IDL attribute values get validated and (if too small) rejected with an exception. Can be omitted or set to <code>null</code> or <code>undefined</code> to signify no minimum value.</li> <li><strong><code>max</code> (number, optional)</strong>: Largest possible value. Defaults to <code>Infinity</code>. Content attribute values greater than <code>max</code> get clamped, IDL attribute values get validated and (if too large) rejected with an exception. Can be omitted or set to <code>null</code> or <code>undefined</code> to signify no maximum value.</li> <li><strong><code>allowNaN</code> (boolean, optional)</strong>: Whether or not <code>NaN</code> is allowed. Defaults to <code>false</code>.</li> <li><strong><code>nullable</code> (boolean, optional)</strong>: Whether or not <code>null</code> and <code>undefined</code> (with the latter converting to <code>null</code>) are allowed. Defaults to <code>false</code>.</li> </ul> <h4 id="behavior-overview-for-transformer-number">Behavior overview for transformer <code>number()</code></h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute (when used with <code>@attr()</code>)</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute to value <code>x</code></td> <td><code>minmax(opts.min, opts.max, toNumber(x, allowNaN))</code></td> <td>String(IDL attribute value)</td> </tr> <tr> <td>Set IDL attribute to out-of-range value</td> <td>RangeError</td> <td>String(IDL attribute value)</td> </tr> <tr> <td>Set IDL attribute to <code>null</code> or <code>undefined</code></td> <td><code>null</code> is <code>nullable</code> is true, otherwise <code>0</code></td> <td>Removed if <code>nullable</code> is true, otherwise String(IDL attribute value)</td> </tr> <tr> <td>Set content attribute to value <code>x</code></td> <td><code>minmax(opts.min, opts.max, toNumber(x, allowNaN))</code></td> <td>As set</td> </tr> <tr> <td>Set content attribute to non-numeric value</td> <td>No change, or NaN if option <code>allowNaN</code> is <code>true</code></td> <td>As set</td> </tr> <tr> <td>Set content attribute to out-of-range value</td> <td>No change</td> <td>As set</td> </tr> <tr> <td>Remove content attribute</td> <td><code>null</code> is <code>nullable</code> is true, otherwise initial value or <code>0</code></td> <td>Removed</td> </tr> </tbody></table> <h3 id="transformer-intoptions-intoptions--">Transformer <code>int(options: IntOptions = {})</code></h3> <p>Implements a bigint attribute. Content attribute values are expressed as plain numeric strings without the trailing <code>n</code> used in JavaScript&#39;s BigInt literal syntax.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, int } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// With default options (see below)</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">int</span>()) accessor foo = <span class="hljs-number">0n</span>;

  <span class="hljs-comment">// With all options set</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">int</span>({ <span class="hljs-attr">min</span>: <span class="hljs-number">0n</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">10n</span>, <span class="hljs-attr">nullable</span>: <span class="hljs-literal">false</span> })) accessor bar = <span class="hljs-number">0n</span>;
}
</code></pre><p>The transformer allows <code>null</code> and <code>undefined</code> (with the latter converting to <code>null</code>) if the option <code>nullable</code> is set to <code>true</code>. In all other cases, the IDL attribute setter throws an exception when its input cannot be converted to BigInt.</p> <h4 id="options-for-transformer-int">Options for transformer <code>int()</code></h4> <ul> <li><strong><code>min</code> (bigint, optional)</strong>: Smallest possible value. Defaults to the minimum possible bigint value. Content attribute values less than <code>min</code> get clamped, IDL attribute values get validated and (if too small) rejected with an exception. Can be omitted or set to <code>null</code> or <code>undefined</code> to signify no minimum value.</li> <li><strong><code>max</code> (bigint, optional)</strong>: Largest possible value. Defaults to the maximum possible bigint value. Content attribute values greater than <code>max</code> get clamped, IDL attribute values get validated and (if too large) rejected with an exception. Can be omitted or set to <code>null</code> or <code>undefined</code> to signify no maximum value.</li> <li><strong><code>nullable</code> (boolean, optional)</strong>: Whether or not <code>null</code> and <code>undefined</code> (with the latter converting to <code>null</code>) are allowed. Defaults to <code>false</code>.</li> </ul> <h4 id="behavior-overview-for-transformer-int">Behavior overview for transformer <code>int()</code></h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute (when used with <code>@attr()</code>)</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute to value <code>x</code></td> <td><code>minmax(ops.min, opts.max, BigInt(x))</code></td> <td>String(IDL attribute value)</td> </tr> <tr> <td>Set IDL attribute to out-of-range value</td> <td>RangeError</td> <td>String(IDL attribute value)</td> </tr> <tr> <td>Set IDL attribute to <code>null</code> or <code>undefined</code></td> <td><code>null</code> is <code>nullable</code> is true, otherwise <code>0n</code></td> <td>Removed if <code>nullable</code> is true, otherwise String(IDL attribute value)</td> </tr> <tr> <td>Set IDL attribute to non-int value</td> <td><code>BigInt(x)</code></td> <td>String(IDL attribute value)</td> </tr> <tr> <td>Set content attribute to value <code>x</code></td> <td><code>minmax(opts.min, opts.max, BigInt(x))</code></td> <td>As set</td> </tr> <tr> <td>Set non-int content attribute</td> <td>Clamp to Int if float, otherwise no change</td> <td>As set</td> </tr> <tr> <td>Remove content attribute</td> <td><code>null</code> is <code>nullable</code> is true, otherwise initial value or <code>0</code></td> <td>Removed</td> </tr> </tbody></table> <h3 id="transformer-bool">Transformer <code>bool()</code></h3> <p>Implements a boolean attribute. Modeled after built-in boolean attributes such as <code>disabled</code>. Changes to the IDL attribute values <em>toggle</em> the content attribute and do not just change the content attribute&#39;s value.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, bool } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-keyword">class</span> <span class="class_ hljs-title">DemoElement</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">bool</span>()) accessor foo = <span class="hljs-literal">false</span>;
}
</code></pre><p>In this case, the IDL attribute <code>foo</code> always represents a boolean. Any non-boolean value gets coerced to booleans. If the content attribute <code>foo</code> gets set to any value (including the empty string), <code>foo</code> returns <code>true</code> - only a missing content attribute counts as <code>false</code>. Conversely, the content attribute will be set to the empty string when the IDL attribute is <code>true</code> and the attribute will be removed when the IDL attribute is <code>false</code>.</p> <p>If you want your content attribute to represent <code>&quot;false&quot;</code> as a string value, you can use the <code>literal()</code> transformer with the strings <code>&quot;true&quot;</code> and <code>&quot;false&quot;</code>.</p> <h4 id="behavior-overview-for-transformer-bool">Behavior overview for transformer <code>bool()</code></h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute (when used with <code>@attr()</code>)</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute to value <code>x</code></td> <td><code>Boolean(x)</code></td> <td>Removed when IDL attribute is <code>false</code>, otherwise set to empty string</td> </tr> <tr> <td>Set content attribute to <code>x</code></td> <td><code>true</code></td> <td>As set</td> </tr> <tr> <td>Remove content attribute</td> <td><code>false</code></td> <td>Removed</td> </tr> </tbody></table> <h3 id="transformer-listoptions-listoptions---">Transformer <code>list(options: ListOptions = {})</code></h3> <p>Implements an attribute with an array of values, defined by another transformer. The <code>list()</code> transformer passes individual items to the transformer passed in the options and deals with content attributes by splitting and/joining stringified array contents:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, list, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">list</span>({ <span class="hljs-attr">transform</span>: <span class="function_ hljs-title">number</span>(), <span class="hljs-attr">separator</span>: <span class="hljs-string">&quot;,&quot;</span> })) accessor numbers = [<span class="hljs-number">0</span>];
}
</code></pre><p>This parses the content attribute <code>numbers</code> as a comma-separated list of strings, which are in turn parsed into numbers by the <code>number()</code> transformer passed to the <code>list()</code> transformers options. If the content attribute gets set to something other than a comma-separated list of numeric strings, the attribute&#39;s value resets back to the initial value <code>[0]</code>. Any attempt at setting the IDL attribute to values other arrays of will result in an exception outright. Depending on the transformer the array&#39;s content may be subject to further validation and/or transformations.</p> <p>Note that when parsing a content attribute string, values are trimmed and empty strings are filtered out before they are passed on to the inner transformer:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, list, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">list</span>({ <span class="hljs-attr">transform</span>: <span class="function_ hljs-title">number</span>() })) accessor foo = [<span class="hljs-number">0</span>];
}
<span class="hljs-keyword">const</span> el = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();
el.<span class="function_ hljs-title">setAttribute</span>(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;   1, , ,,2   ,3     &quot;</span>);
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(el.<span class="hljs-property">foo</span>); <span class="hljs-comment">// &gt; [1, 2, 3]</span>
</code></pre><h4 id="options-for-listoptions">Options for <code>list(options?)</code></h4> <ul> <li><strong><code>separator</code> (string, optional)</strong>: Separator string. Defaults to <code>&quot;,&quot;</code></li> <li><strong><code>transform</code> (Transformer)</strong>: Transformer to use, eg. <code>string()</code> for a list of strings, <code>number()</code> for numbers etc.</li> </ul> <h4 id="behavior-overview-for-transformer-list">Behavior overview for transformer <code>list()</code></h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute (when used with <code>@attr()</code>)</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute</td> <td>Exception is not an array, otherwise array with content guarded by <code>options.transformer.validate</code></td> <td>IDL attribute values joined with <code>options.separator</code></td> </tr> <tr> <td>Set content attribute</td> <td>Attribute value is split on the separator, then trimmed, then non-empty strings are passed into <code>options.transformer.parse</code></td> <td>As set</td> </tr> <tr> <td>Remove content attribute</td> <td>Initial value or empty array</td> <td>Removed</td> </tr> </tbody></table> <h3 id="transformer-literaloptions-literaloptions--">Transformer <code>literal(options: LiteralOptions = {})</code></h3> <p>Implements an attribute with a finite number of valid values. Should really be called &quot;enum&quot;, but that&#39;s a reserved word in JavaScript. It works by declaring the valid list of values and a matching transformer. If, for example, the list of valid values consists of strings, then the <code>string()</code> transformer is the right transformer to use:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, literal, string } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">literal</span>({ <span class="hljs-attr">values</span>: [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>], <span class="hljs-attr">transform</span>: <span class="function_ hljs-title">string</span>() })) accessor foo =
    <span class="hljs-string">&quot;A&quot;</span>;
}
</code></pre><p>In this case, the content attribute can be set to any value (as is usual in HTML), but if the content attribute gets set to a value other than <code>A</code> or <code>B</code>, the IDL attribute&#39;s value will remain unchanged. Any attempt at setting the IDL attribute to values other than <code>A</code> or <code>B</code> will result in an exception.</p> <p>The default value is either the value the accessor was initialized with or, if the accessor has no initial value, the first element in <code>values</code>.</p> <details> <summary>Notes for TypeScript</summary> <p>To use <code>literal()</code> with literal union types, make sure that the <code>values</code> option is <em>not</em> subject to type widening, eg. via <code>as const</code>:</p> <pre><code class="hljs language-javascript">@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;test-element&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">TestElement</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {

  <span class="hljs-comment">// Works: values is [&quot;a&quot;, &quot;b&quot;]</span>
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">literal</span>({ <span class="hljs-attr">values</span>: [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>, <span class="hljs-attr">transform</span>: <span class="function_ hljs-title">string</span>() }))
  accessor <span class="hljs-attr">bah</span>: <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> = <span class="hljs-string">&quot;a&quot;</span>;

  <span class="hljs-comment">// Errors: values is string[]</span>
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">literal</span>({ <span class="hljs-attr">values</span>: [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>], <span class="hljs-attr">transform</span>: <span class="function_ hljs-title">string</span>() }))
  accessor <span class="hljs-attr">bbb</span>: <span class="hljs-string">&quot;a&quot;</span> | <span class="hljs-string">&quot;b&quot;</span> = <span class="hljs-string">&quot;a&quot;</span>;
}
</code></pre><p>The ordering of <code>values</code> is not important.</p> </details> <h4 id="options-for-literaloptions">Options for <code>literal(options?)</code></h4> <ul> <li><strong><code>values</code> (array)</strong>: List of valid values. Must contain at least one element.</li> <li><strong><code>transform</code> (Transformer)</strong>: Transformer to use, eg. <code>string()</code> for a list of strings, <code>number()</code> for numbers etc.</li> </ul> <h4 id="behavior-overview-for-transformer-literal">Behavior overview for transformer <code>literal()</code></h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute (when used with <code>@attr()</code>)</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute value to <code>x</code></td> <td>Exception if not in <code>options.values</code>, otherwise defined by <code>options.transformer.validate</code></td> <td>Defined by <code>options.transformer.stringify</code></td> </tr> <tr> <td>Set content attribute to <code>x</code></td> <td>Parsed by <code>options.transformer.parse</code>. If the result is in <code>options.values</code>, result, otherwise no change</td> <td>As set</td> </tr> <tr> <td>Remove attribute</td> <td>Initial value or first element in <code>options.values</code></td> <td>Removed</td> </tr> </tbody></table> <h3 id="transformer-jsonoptions-jsonoptions--">Transformer <code>json(options: JSONOptions = {})</code></h3> <p>Implements an attribute that can take any value. When used with <code>@attr()</code>, the value must be serializable with JSON in order to be reflected as a content attribute. When used with <code>@prop()</code>, no restrictions apply.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, prop, json } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Must be valid JSON when used with @attr()</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">json</span>()) accessor foo = { <span class="hljs-attr">user</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&quot;&quot;</span> };
  <span class="hljs-comment">// When used with prop, any value can be used</span>
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">json</span>()) accessor foo = { <span class="hljs-attr">value</span>: <span class="hljs-number">42n</span> };
}
</code></pre><p>Content attributes, defined with <code>@attr()</code>, are parsed with <code>JSON.parse()</code>. In this case, any invalid JSON is represented with the data used to initialize the accessor. Using the IDL attribute&#39;s setter with inputs than can&#39;t be serialized with JSON.<code>stringify()</code> throws errors. This transformer is really just a wrapper around <code>JSON.parse()</code> and <code>JSON.stringify()</code> without any object validation. Equality is checked with <code>===</code>.</p> <details> <summary>Notes for TypeScript</summary> Even though the transformer will accept literally any JSON-serializable value at runtime, TypeScript may infer a more restrictive type from the accessor's initial value. Decorators can't currently change the type of class members they are applied to, so you man need to provide a type annotation. </details> <h4 id="options-for-jsonoptions">Options for <code>json(options?)</code></h4> <ul> <li><strong><code>reviver</code> (function, optional)</strong>: The <code>reviver</code> argument to use with <code>JSON.parse()</code>, if any. Only of use when used with <code>@attr()</code></li> <li><strong><code>replacer</code> (function, optional)</strong>: The <code>replacer</code> argument to use with <code>JSON.stringify()</code>, if any. Only of use when used with <code>@attr()</code></li> </ul> <h4 id="behavior-overview-for-transformer-json-when-used-with-attr">Behavior overview for transformer <code>json()</code> (when used with <code>@attr()</code>)</h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute value to <code>x</code></td> <td><code>JSON.parse(JSON.stringify(x))</code></td> <td><code>JSON.stringify(idlValue, null, options.reviver)</code></td> </tr> <tr> <td>Set content attribute to <code>x</code></td> <td>No change if invalid JSON, otherwise <code>JSON.parse(x, options.receiver)</code></td> <td>As set</td> </tr> <tr> <td>Remove content attribute</td> <td>Initial value or <code>undefined</code></td> <td>Removed</td> </tr> </tbody></table> <h4 id="behavior-overview-for-transformer-json-when-used-with-prop">Behavior overview for transformer <code>json()</code> (when used with <code>@prop()</code>)</h4> <table> <thead> <tr> <th>Operation</th> <th>IDL attribute value</th> <th>Content attribute</th> </tr> </thead> <tbody><tr> <td>Set IDL attribute value to <code>x</code></td> <td><code>x</code></td> <td>-</td> </tr> </tbody></table> <h3 id="transformer-any">Transformer <code>any()</code></h3> <p>Implements a transformer that does no type checking at all and falls back to the global <code>String</code> function for serializing to content attributes. Use this if you really don&#39;t care about types.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, prop, any } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">any</span>()) accessor <span class="hljs-attr">whatever</span>: any = <span class="hljs-number">42</span>;
}
</code></pre><p>Transformers returned from calling <code>any()</code> make for great prototypes for your own custom transformer. Just note that transformers are bags of functions and <em>not</em> classes, so you will need to use <code>Object.setPrototypeOf()</code> and friends to &quot;extend&quot; transformers.</p> <details> <summary>Notes for TypeScript</summary> Even though the transformer will accept literally any value at runtime, TS may infer a more restrictive type from the accessor's initial values. Decorators can't currently change the type of class members they are applied to, so you may need to provide an `any` type annotation. </details> <h3 id="transformer-event">Transformer <code>event()</code></h3> <p>Implements old-school inline event handler attributes in the style of <code>onclick=&quot;console.log(42)&quot;</code>. To work properly, this should only be used in conjunction with <code>@attr()</code> (with reflectivity enabled) and on a non-private, non-static accessor that has a name starting with <code>on</code>:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, eventHandler } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">event</span>()) accessor <span class="hljs-attr">onfoo</span>: (<span class="hljs-function">(<span class="hljs-params">evt: Event</span>) =&gt;</span> <span class="hljs-keyword">void</span>) | <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span>;
}
</code></pre><p>This can then be used in HTML:</p> <pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">my-test</span> <span class="hljs-attr">onfoo</span>=<span class="hljs-string">&quot;console.log(&#x27;Foo event:&#x27;, event)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-test</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">querySelector</span>(<span class="hljs-string">&quot;my-test&quot;</span>).<span class="function_ hljs-title">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="class_ hljs-title">Event</span>(<span class="hljs-string">&quot;foo&quot;</span>));
  <span class="hljs-comment">// Logs &quot;&#x27;Foo event:&#x27;, Event{type: &quot;foo&quot;}&quot;</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre><p>Or in JavaScript:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> testEl = <span class="hljs-variable language_">document</span>.<span class="function_ hljs-title">createElement</span>(<span class="hljs-string">&quot;my-test&quot;</span>);
testEl.<span class="hljs-property">onfoo</span> = <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Foo event:&quot;</span>, event);
testEl.<span class="function_ hljs-title">dispatchEvent</span>(<span class="hljs-keyword">new</span> <span class="class_ hljs-title">Event</span>(<span class="hljs-string">&quot;foo&quot;</span>));
<span class="hljs-comment">// Logs &quot;&#x27;Foo event:&#x27;, Event{type: &quot;foo&quot;}&quot;</span>
</code></pre><p>Regular &quot;proper&quot; <code>addEventListener()</code> is obviously also always available.</p> <p>It should be noted that for built-in events that bubble, inline event handlers can be added to <em>any</em> element in order to facilitate event delegation. These event handlers are considered global event handlers, and all custom inline event handlers are obviously not global - they can only be used on the components that explicitly implement them.</p> <h4 id="behavior-overview-for-transformer-event">Behavior overview for transformer <code>event()</code></h4> <p>The behavior of <code>event()</code> matches the behavior of built-in event handlers like <code>onclick</code>.</p> <h2 id="metadata">Metadata</h2> <p>HTML elements do usually not expose any metadata, even though knowing the names and data types for content attributes would be quite useful sometimes. Ornament exposes a few metadata helper functions that help in scenarios where meta-programming components (eg. SSR) is required.</p> <h3 id="gettagnameinstanceorctor"><code>getTagName(instanceOrCtor)</code></h3> <p>Given an instance or custom element constructor, this function returns <strong>the element&#39;s tag name</strong>. It returns <code>null</code> if the object in question is not a custom element defined via <code>@define()</code>:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, getTagName } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="function_ hljs-title">getTagName</span>(<span class="class_ hljs-title">Test</span>));
<span class="hljs-comment">// &gt; &quot;my-test&quot;</span>

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="function_ hljs-title">getTagName</span>(<span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>()));
<span class="hljs-comment">// &gt; &quot;my-test&quot;</span>
</code></pre><p>This serves roughly the same function as the standard <a href="https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/getName">CustomElementRegistry.getName() method</a> but does not require access to the specific CustomElementRegistry that the element is registered with.</p> <h3 id="listattributesinstanceorctor"><code>listAttributes(instanceOrCtor)</code></h3> <p><strong>Lists the content attribute names</strong> that were defined via <code>@attr()</code> on the custom element (or constructor) in question:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, string, listAttributes } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>()) accessor foo = <span class="hljs-string">&quot;&quot;</span>;
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>(), { <span class="hljs-attr">as</span>: <span class="hljs-string">&quot;asdf&quot;</span> }) accessor bar = <span class="hljs-string">&quot;&quot;</span>;
}

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="function_ hljs-title">listAttributes</span>(<span class="class_ hljs-title">Test</span>));
<span class="hljs-comment">// &gt; [&quot;foo&quot;, &quot;asdf&quot;]</span>

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="function_ hljs-title">listAttributes</span>(<span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>()));
<span class="hljs-comment">// &gt; [&quot;foo&quot;, &quot;asdf&quot;]</span>
</code></pre><p>This is roughly analogous to the <code>observedAttributes</code> static property on custom element classes, but only lists content attributes defined with ornament&#39;s <code>@attr()</code> - manually defined attributes and IDL attributes defined with <code>@prop()</code> are excluded.</p> <h3 id="getattributeinstanceorctor-contentattributename"><code>getAttribute(instanceOrCtor, contentAttributeName)</code></h3> <p><strong>Returns the IDL attribute name and transformer</strong> used to define a content attribute:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, number, getAttribute } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Requires non-negative values</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span> }), { <span class="hljs-attr">as</span>: <span class="hljs-string">&quot;asdf&quot;</span> }) accessor bar = <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">const</span> { prop, transformer } = <span class="function_ hljs-title">getAttribute</span>(<span class="class_ hljs-title">Test</span>, <span class="hljs-string">&quot;asdf&quot;</span>);

<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(prop);
<span class="hljs-comment">// &gt; &quot;bar&quot; - the backend accessor for the content attribute &quot;asdf&quot;</span>

transformer.<span class="function_ hljs-title">parse</span>(<span class="hljs-string">&quot;-1&quot;</span>);
<span class="hljs-comment">// &gt; 0; input clamped to valid value</span>

transformer.<span class="function_ hljs-title">validate</span>(-<span class="hljs-number">1</span>, <span class="hljs-literal">true</span>);
<span class="hljs-comment">// Throws an error; the transformer only accepts nonnegative numbers</span>
</code></pre><p>This is particularly useful if you need access to the parsing and stringification logic for content attributes for eg. SSR.</p> <h2 id="event-bus">Event Bus</h2> <p>Ornament runs intra-component communication over an internal event bus. You will almost certainly never need to access it directly, but there is is an API just in case.</p> <table> <thead> <tr> <th>Event</th> <th>Cause</th> <th>Event type</th> <th>Payload (<code>args</code> property on the event object)</th> </tr> </thead> <tbody><tr> <td><code>init</code></td> <td>Constructor ran to completion</td> <td><code>OrnamentEvent&lt;&quot;init&quot;&gt;</code></td> <td><code>[]</code></td> </tr> <tr> <td><code>connected</code></td> <td><code>connectedCallback()</code> fired</td> <td><code>OrnamentEvent&lt;&quot;connected&quot;&gt;</code></td> <td><code>[]</code></td> </tr> <tr> <td><code>disconnected</code></td> <td><code>disconnectedCallback()</code> fired</td> <td><code>OrnamentEvent&lt;&quot;disconnected&quot;&gt;</code></td> <td><code>[]</code></td> </tr> <tr> <td><code>adopted</code></td> <td><code>adoptedCallback()</code> fired</td> <td><code>OrnamentEvent&lt;&quot;adopted&quot;&gt;</code></td> <td><code>[]</code></td> </tr> <tr> <td><code>prop</code></td> <td>IDL attribute change (<code>@prop</code> or <code>@attr</code>)</td> <td><code>OrnamentEvent&lt;&quot;prop&quot;&gt;</code></td> <td><code>[Name: string | symbol, NewValue: any]</code></td> </tr> <tr> <td><code>attr</code></td> <td>Content attribute change (<code>@attr</code>)</td> <td><code>OrnamentEvent&lt;&quot;attr&quot;&gt;</code></td> <td><code>[Name: string, OldValue: string | null, NewValue: string | null]</code></td> </tr> <tr> <td><code>formAssociated</code></td> <td><code>formAssociatedCallback()</code> fired</td> <td><code>OrnamentEvent&lt;&quot;formAssociated&quot;&gt;</code></td> <td>`[Owner: HTMLFormElement | null]</td> </tr> <tr> <td><code>formReset</code></td> <td><code>formResetCallback()</code> fired</td> <td><code>OrnamentEvent&lt;&quot;formReset&quot;&gt;</code></td> <td><code>[]</code></td> </tr> <tr> <td><code>formDisabled</code></td> <td><code>formDisabledCallback()</code> fired</td> <td><code>OrnamentEvent&lt;&quot;formDisabled&quot;&gt;</code></td> <td><code>[Disabled: boolean]</code></td> </tr> <tr> <td><code>formStateRestore</code></td> <td><code>formStateRestoreCallback()</code> fired</td> <td><code>OrnamentEvent&lt;&quot;formStateRestore&quot;&gt;</code></td> <td><code>[Reason: &quot;autocomplete&quot; | &quot;restore&quot;]</code></td> </tr> </tbody></table> <details> <summary>Notes for TypeScript</summary> <p>You can declare additions to the global interface <code>OrnamentEventMap</code> to extend this list with your own events.</p> </details> <h3 id="triggerinstance-name-payload"><code>trigger(instance, name, ...payload)</code></h3> <p>Dispatches an event on the event bus for the component <code>instance</code>. The arguments <code>payload</code> must be all the for the <code>args</code> property on the event object on the event object (eg. a single boolean for for <code>formDisabled</code>).</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { trigger } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// Dispatches an &quot;connected&quot; event. This will run all methods on &quot;someElement&quot;</span>
<span class="hljs-comment">// that were decorated with @connect().</span>
<span class="function_ hljs-title">trigger</span>(someElement, <span class="hljs-string">&quot;connected&quot;</span>); <span class="hljs-comment">// note no args</span>

<span class="hljs-comment">// Dispatches an &quot;prop&quot; event. This will run all methods on &quot;someElement&quot;</span>
<span class="hljs-comment">// that were decorated with @reactive(), provided the &quot;foo&quot; key is not excluded</span>
<span class="hljs-comment">// in the setup of the @reactive decorator</span>
<span class="function_ hljs-title">trigger</span>(someElement, <span class="hljs-string">&quot;prop&quot;</span>, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-number">42</span>); <span class="hljs-comment">// note args for prop name and value</span>
</code></pre><h3 id="listeninstance-name-callback-options"><code>listen(instance, name, callback, options?)</code></h3> <p>Listens to events on the event bus for the component <code>instance</code>. The event bus is an instance of <code>EventTarget</code>, which means that you can pass any and all <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#options">event listener options</a> as the last argument.</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { listen } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// Listen for &quot;prop&quot; event on the event bus for &quot;someElement&quot;</span>
<span class="function_ hljs-title">listen</span>(someElement, <span class="hljs-string">&quot;prop&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> [name, value] = event.<span class="hljs-property">args</span>;
  <span class="hljs-variable language_">window</span>.<span class="function_ hljs-title">alert</span>(<span class="hljs-string">`Attribute <span class="hljs-subst">${name}</span> was changed to <span class="hljs-subst">${value}</span>!`</span>);
});
</code></pre><h3 id="class-ornamenteventk-extends-keyof-ornamenteventmap">class <code>OrnamentEvent&lt;K extends keyof OrnamentEventMap&gt;</code></h3> <p>Event type used on the internal event bus. Only really useful if you want to create your own events while using TypeScript.</p> <h2 id="other-utilities">Other utilities</h2> <h3 id="getinternalsinstance-htmlelement-elementinternals"><code>getInternals(instance: HTMLElement): ElementInternals</code></h3> <p>Get the <a href="https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals">ElementInternals</a> for a component instance. While <code>getInternals()</code> be called as often as required, component&#39;s <code>attachInternals()</code> methods are still single-use:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, getInternals } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {}
<span class="hljs-keyword">const</span> testEl = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();

<span class="hljs-keyword">const</span> internals1 = <span class="function_ hljs-title">getInternals</span>(testEl);
<span class="hljs-keyword">const</span> internals2 = testEl.<span class="function_ hljs-title">attachInternals</span>();
<span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(internals1 === internals2); <span class="hljs-comment">// &gt; true</span>

<span class="function_ hljs-title">getInternals</span>(testEl); <span class="hljs-comment">// works a second time</span>
<span class="function_ hljs-title">getInternals</span>(testEl); <span class="hljs-comment">// works a third time</span>
testEl.<span class="function_ hljs-title">attachInternals</span>()).<span class="hljs-property">to</span>.<span class="hljs-keyword">throw</span>(); <span class="hljs-comment">// &gt; Exception on second use</span>
</code></pre><h2 id="symbols">Symbols</h2> <h3 id="no_value"><code>NO_VALUE</code></h3> <p>Transformers can return a special symbol to indicate that they were unable to parse an input. This symbol is exported by Ornament as <code>NO_VALUE</code> and is also available behind the key <code>&quot;ORNAMENT_NO_VALUE&quot;</code> in the global symbol registry.</p> <h3 id="metadata-1"><code>METADATA</code></h3> <p>Ornament, being a collection of decorators, stores its metadata in <a href="https://github.com/tc39/proposal-decorator-metadata">Decorator Metadata</a>. To avoid collisions with other libraries, the actual metadata is hidden behind a symbol that is exported by Ornament as <code>ORNAMENT_METADATA_KEY</code> or available behind the key <code>&quot;ORNAMENT_METADATA_KEY&quot;</code> in the global symbol registry. The contents of the metadata record should not be considered part of Ornament&#39;s stable API and could change at any moment. Use the metadata API instead.</p> <h2 id="troubleshooting">Troubleshooting</h2> <h3 id="typeerror-cannot-read-private-member-from-an-object-whose-class-did-not-declare-it">TypeError: Cannot read private member from an object whose class did not declare it</h3> <p>This usually happens when methods decorated with <code>@init()</code> run at inopportune times. Consider the following example:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, init } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-keyword">function</span> <span class="function_ hljs-title">otherDecorator</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">OtherMixin</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">target</span> {
    #secret = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">get</span> <span class="function_ hljs-title">foo</span>() {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#secret; <span class="hljs-comment">// &lt;- Fails because @init() runs too early</span>
    }
  };
}

@otherDecorator
@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;foo-bar&quot;</span>) <span class="hljs-comment">// If this was before @otherDecorator it would work</span>
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">init</span>() <span class="hljs-comment">// Runs after the constructor of Test has run, does not wait for the mixin class</span>
  <span class="function_ hljs-title">method</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>);
  }
}

<span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();
</code></pre><p>In this scenario, <code>@define()</code> sets up to trigger <code>@init()</code> once the constructor of <code>Test</code> has finished. Inside <code>Test</code>, the method <code>method()</code> accesses the getter <code>foo</code> which is provided by the decorator <code>@otherDecorator</code>. The getter in turn tries to accesses the private field <code>#secret</code>, but fails with an exception. This happens because <code>@define()</code> installs logic that triggers the init event on the constructor for class <code>Test</code>, but the resulting class gets extended in turn by <code>OtherMixin</code>.</p> <pre><code class="hljs language-pseudocode">OtherMixinConstructor(
  DefineMixinConstructor(
    TestConstructor(
      HTMLElementConstructor()
    )
    // &lt;---- init event happens here, after TestConstructor has run
  )
  // &lt;---- finishes only after the init event has happened
)
</code></pre><p>This results in the event running before the private field <code>#secret</code> is fully initialized. The simplest way to remedy this situation is to apply <code>@otherDecorator</code> first. You might also want to consider using <code>@connected()</code> instead of <code>@init()</code>.</p> <p>This is not a bug in Ornament, but rather a simple effect of how mixin classes are subclasses of their targets. Because <code>@init()</code> is equivalent to calling the decorated method in the constructor, the effect can be reproduced <a href="https://babeljs.io/repl#?browsers=defaults&build=&builtIns=false&corejs=3.21&spec=false&loose=false&code_lz=GYVwdgxgLglg9mABAEwKYTgJwIZSwCim0wHNUoBKRAbwChFFNyRMkIAbbAZy8QBF0WXFgCyMAB4wkqcVFRhkvIqXI16DRAGIu6JlEQBeRABYATAG51DMvuCpcLVPip0NGvSyRQAFjC4A6bV1ySzcAX3UwywiGWgABNAwcPExaDm5eAEE1BgwwLihMEGgCFytEPK44dlR_djgSQl8AuwcmClDECIjaMFQAd0RM50sgA&debug=false&forceAllTransforms=false&modules=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=env%2Creact%2Cstage-2&prettier=false&targets=&version=7.24.5&externalPlugins=%40babel%2Fplugin-proposal-decorators%407.23.9&assumptions=%7B%7D">without involving Ornament at all:</a></p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">function</span> <span class="function_ hljs-title">decorator</span>(<span class="hljs-params">target</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">DecoratorMixin</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">target</span> {
    #secret = <span class="hljs-number">42</span>;
    <span class="hljs-keyword">get</span> <span class="function_ hljs-title">feature</span>() {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#secret;
    }
  };
}

@decorator
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">A</span> {
  <span class="function_ hljs-title">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">feature</span>);
  }
}

<span class="hljs-keyword">new</span> <span class="function_ hljs-title">A</span>();
</code></pre><h2 id="cookbook">Cookbook</h2> <h3 id="debounced-reactive">Debounced reactive</h3> <p><code>@reactive()</code> causes its decorated method to get called for once for <em>every</em> attribute and property change. This is sometimes useful, but sometimes you will want to batch method calls for increased efficiency. This is easy if you combine <code>@reactive()</code> with <code>@debounce()</code>:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, prop, reactive, debounce int } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">TestElement</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">int</span>()) accessor value = <span class="hljs-number">0</span>;

  @<span class="function_ hljs-title">reactive</span>()
  @<span class="function_ hljs-title">debounce</span>()
  #<span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Value is now&quot;</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);
  }
}

<span class="hljs-keyword">let</span> el = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">TestElement</span>();
el.<span class="hljs-property">value</span> = <span class="hljs-number">1</span>;
el.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;
el.<span class="hljs-property">value</span> = <span class="hljs-number">2</span>;

<span class="hljs-comment">// Only logs &quot;Value is now 3&quot;</span>
</code></pre><h3 id="rendering-shadow-dom-with-uhtml">Rendering shadow DOM with uhtml</h3> <p>Ornament does not directly concern itself with rendering Shadow DOM, but you can combine Ornament with suitable libraries such as <a href="https://github.com/WebReflection/uhtml">uhtml</a>:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { render, html } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;uhtml&quot;</span>;
<span class="hljs-keyword">import</span> { define, prop, reactive, debounce int } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;counter-element&quot;</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="class_ hljs-title">CounterElement</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">int</span>()) accessor value = <span class="hljs-number">0</span>;

  @<span class="function_ hljs-title">reactive</span>()
  @<span class="function_ hljs-title">debounce</span>()
  #<span class="function_ hljs-title">render</span>(<span class="hljs-params"></span>) {
    <span class="function_ hljs-title">render</span>(
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadowRoot</span> ?? <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> }),
      html`<span class="language-xml">
        Current value: </span><span class="hljs-subst">${<span class="hljs-variable language_">this</span>.value}</span><span class="language-xml">
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">.click</span>=<span class="hljs-string">{()</span> =&gt;</span> ++this.value}&gt;Add 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      `</span>
    );
  }
}
</code></pre><p>This component uses an event handler to update the decorated accessor <code>value</code>, which in turn causes the <code>@reactive()</code> method <code>#render()</code> to update the UI accordingly - debounced with <code>@debounce()</code> for batched updates.</p> <h3 id="rendering-shadow-dom-with-preact">Rendering shadow DOM with Preact</h3> <p>You can also use <a href="https://preactjs.com/">Preact</a> to render shadow DOM:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, number, reactive, connected } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;
<span class="hljs-keyword">import</span> { <span class="class_ hljs-title">Fragment</span>, h, render } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;preact&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;click-counter&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">ClickCounter</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  #shadow = <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;closed&quot;</span> });

  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span> }), { <span class="hljs-attr">reflective</span>: <span class="hljs-literal">false</span> }) accessor up = <span class="hljs-number">0</span>;
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">number</span>({ <span class="hljs-attr">min</span>: <span class="hljs-number">0</span> }), { <span class="hljs-attr">reflective</span>: <span class="hljs-literal">false</span> }) accessor down = <span class="hljs-number">0</span>;

  @<span class="function_ hljs-title">connected</span>()
  @<span class="function_ hljs-title">reactive</span>()
  <span class="function_ hljs-title">render</span>(<span class="hljs-params"></span>) {
    <span class="function_ hljs-title">render</span>(
      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.up++}&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        Total: <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>{this.up + this.down}<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> this.down--}&gt;-1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/&gt;</span></span>,
      <span class="hljs-variable language_">this</span>.#shadow,
    );
  }
}
</code></pre><p>In the case of Web Components and Ornament, it makes some sense to use class members for local state instead of hooks.</p> <h3 id="read-only-property">Read-only property</h3> <p>You can create a writable private accessor with <code>@prop()</code> and manually expose a public getter. This keeps reactive functions working, but only allows readonly access from outside the component:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, reactive, string } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Writable, but private</span>
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">string</span>()) accessor #foo = <span class="hljs-string">&quot;Starting value&quot;</span>;

  <span class="hljs-comment">// Provides public readonly access to #foo</span>
  <span class="hljs-keyword">get</span> <span class="function_ hljs-title">foo</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#foo;
  }

  <span class="function_ hljs-title">change</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.#foo++;
  }

  <span class="hljs-comment">// Reacts to changes to #foo, which can only be caused by calling the method</span>
  <span class="hljs-comment">// `change()`</span>
  @<span class="function_ hljs-title">reactive</span>()
  <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-variable language_">this</span>.#foo);
  }
}
</code></pre><h3 id="custom-logic-in-idl-attributes">Custom logic in IDL attributes</h3> <p>The point of the <code>accessor</code> keyword is to generate a getter, setter, and private property in a way that makes it easy to apply a decorator to everything at once. But because the getters and setters are auto-generated, there is no non-decorator way to attach custom logic to <code>accessor</code> members. To work around this for IDL attributes defined via <code>@attr()</code> or <code>@prop()</code>, you can build a and decorate a private or symbol accessor that you then expose with a custom facade:</p> <pre><code class="hljs language-javascript">@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  <span class="hljs-comment">// Implements a content attribute &quot;foo&quot; with getters and setters at #secret</span>
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">string</span>(), { <span class="hljs-attr">as</span>: <span class="hljs-string">&quot;foo&quot;</span> }) accessor #secret = <span class="hljs-string">&quot;A&quot;</span>;

  <span class="hljs-comment">// To provide public IDL attributes, we just write a getter/setter pair with</span>
  <span class="hljs-comment">// names matching the content attribute</span>
  <span class="hljs-keyword">get</span> <span class="function_ hljs-title">foo</span>() {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Custom getter logic!&quot;</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#secret; <span class="hljs-comment">// accesses the getter decorated with @attr()</span>
  }

  <span class="hljs-keyword">set</span> <span class="function_ hljs-title">foo</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Custom seter logic!&quot;</span>);
    <span class="hljs-variable language_">this</span>.#secret = value; <span class="hljs-comment">// accesses the setter decorated with @attr()</span>
  }
}
</code></pre><p>Notes for <code>@attr()</code>:</p> <ol> <li>The option <code>as</code> is <em>mandatory</em> when you use <code>@attr()</code> on a private or symbol accessor</li> <li>Ornament throws exceptions if the class does not implement a public API for a content attribute defined with <code>@attr()</code> on a private or symbol accessor</li> </ol> <h3 id="event-delegation">Event delegation</h3> <p>The following example captures all <code>input</code> events fired by <code>&lt;input type=&quot;number&quot;&gt;</code> in the document:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">subscribe</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>, <span class="hljs-string">&quot;input&quot;</span>, {
    <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> evt.<span class="hljs-property">target</span>.<span class="function_ hljs-title">matches</span>(<span class="hljs-string">&quot;input[type-number]&quot;</span>),
  })
  <span class="function_ hljs-title">log</span>(<span class="hljs-params">evt</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(evt); <span class="hljs-comment">// &quot;input&quot; events</span>
  }
}
</code></pre><p>If you&#39;d rather catch event happening in the component&#39;s shadow dom, the syntax gets a bit more gnarly at first:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  root = <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });
  @<span class="function_ hljs-title">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">instance</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, <span class="hljs-string">&quot;input&quot;</span>, {
    <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> evt.<span class="hljs-property">target</span>.<span class="function_ hljs-title">matches</span>(<span class="hljs-string">&quot;input[type-number]&quot;</span>),
  })
  <span class="function_ hljs-title">log</span>(<span class="hljs-params">evt</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(evt); <span class="hljs-comment">// &quot;input&quot; events</span>
  }
}
</code></pre><p>Decorators like <code>@subscribe</code> run when the class definition initializes, and at that point, no class instances (and no shadow DOM to subscribe to) exist. We must therefore provide a function that can return the event target on initialization. To make this less of an eyesore, it makes sense to create a custom decorator for event delegation based on <code>@subscribe</code>:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-keyword">const</span> <span class="function_ hljs-title">handle</span> = (<span class="hljs-params">eventName, selector</span>) =&gt;
  <span class="function_ hljs-title">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">instance</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, eventName, {
    <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> evt.<span class="hljs-property">target</span>.<span class="function_ hljs-title">matches</span>(selector),
  });

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  root = <span class="hljs-variable language_">this</span>.<span class="function_ hljs-title">attachShadow</span>({ <span class="hljs-attr">mode</span>: <span class="hljs-string">&quot;open&quot;</span> });

  @<span class="function_ hljs-title">handle</span>(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-string">&quot;input[type-number]&quot;</span>) <span class="hljs-comment">// Much better!</span>
  <span class="function_ hljs-title">log</span>(<span class="hljs-params">evt</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(evt); <span class="hljs-comment">// &quot;input&quot; events</span>
  }
}
</code></pre><p>Note that the function that <code>@subscribe</code> takes to access event targets can <em>not</em> access a classes private fields. The shadow root has to be publicly accessible (unless you want to mess around with WeakMaps storing ShadowRoots indexed by element instances or something similar).</p> <p>Also note that not all events bubble, so you might want to use event capturing instead:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// This can now handle all events from the shadow root</span>
<span class="hljs-keyword">const</span> <span class="function_ hljs-title">capture</span> = (<span class="hljs-params">eventName, selector</span>) =&gt;
  <span class="function_ hljs-title">subscribe</span>(<span class="hljs-function">(<span class="hljs-params">instance</span>) =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">root</span>, eventName, {
    <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span> evt.<span class="hljs-property">target</span>.<span class="function_ hljs-title">matches</span>(selector),
    <span class="hljs-attr">capture</span>: <span class="hljs-literal">true</span>,
  });
</code></pre><p>Also also note that only composed events propagate through shadow boundaries, which may become important if you want to nest components with shadow dom and also want to use event delegation.</p> <h3 id="custom-defaults">Custom defaults</h3> <p>If you don&#39;t like Ornament&#39;s defaults, remember that decorators and transformers are just functions. This means that you can use partial application to change the default options:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> {
  define,
  attr,
  reactive <span class="hljs-keyword">as</span> baseReactive,
  string,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// @reactive with &quot;keys&quot; always set to [&quot;foo&quot;]</span>
<span class="hljs-keyword">const</span> <span class="function_ hljs-title">reactive</span> = (<span class="hljs-params">options</span>) =&gt; <span class="function_ hljs-title">baseReactive</span>({ ...options, <span class="hljs-attr">keys</span>: [<span class="hljs-string">&quot;foo&quot;</span>] });

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">string</span>()) accessor foo = <span class="hljs-string">&quot;A&quot;</span>; <span class="hljs-comment">// included in options.keys</span>
  @<span class="function_ hljs-title">prop</span>(<span class="function_ hljs-title">string</span>()) accessor bar = <span class="hljs-string">&quot;A&quot;</span>; <span class="hljs-comment">// excluded from options.keys</span>

  @<span class="function_ hljs-title">reactive</span>()
  <span class="function_ hljs-title">log</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(<span class="hljs-string">&quot;Hello&quot;</span>);
  }
}

<span class="hljs-keyword">let</span> test = <span class="hljs-keyword">new</span> <span class="class_ hljs-title">Test</span>();
test.<span class="hljs-property">foo</span> = <span class="hljs-string">&quot;B&quot;</span>; <span class="hljs-comment">//  logs &quot;Hello&quot;</span>
test.<span class="hljs-property">bar</span> = <span class="hljs-string">&quot;B&quot;</span>; <span class="hljs-comment">//  does not log anything</span>
</code></pre><p>The same approach works when you want to create specialized decorators from existing ones...</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, subscribe } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// A more convenient decorator for event delegation</span>
<span class="hljs-keyword">function</span> <span class="function_ hljs-title">listen</span>(<span class="hljs-params">event, selector = <span class="hljs-string">&quot;*&quot;</span></span>) {
  <span class="hljs-keyword">return</span> <span class="function_ hljs-title">subscribe</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>, <span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-function">(<span class="hljs-params">evt</span>) =&gt;</span>
    evt.<span class="hljs-property">target</span>.<span class="function_ hljs-title">matches</span>(selector),
  );
}

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">listen</span>(<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-string">&quot;input[type-number]&quot;</span>)
  <span class="function_ hljs-title">log</span>(<span class="hljs-params">evt</span>) {
    <span class="hljs-variable language_">console</span>.<span class="function_ hljs-title">log</span>(evt);
  }
}
</code></pre><p>... or when you want to create your own transformers:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, number } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-keyword">function</span> <span class="function_ hljs-title">nonnegativeNumber</span>(<span class="hljs-params">otherOptions</span>) {
  <span class="hljs-keyword">return</span> <span class="function_ hljs-title">number</span>({ ...otherOptions, <span class="hljs-attr">min</span>: <span class="hljs-number">0</span> });
}

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">nonnegativeNumber</span>({ <span class="hljs-attr">max</span>: <span class="hljs-number">1337</span> }))
  accessor foo = <span class="hljs-number">42</span>;
}
</code></pre><p>You can also compose decorators, since they are just functions over a target and a context object:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { reactive <span class="hljs-keyword">as</span> baseReactive, connected } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// Combines @reactive() and @connected() into one handy decorator that runs</span>
<span class="hljs-comment">// methods when components connect AND when their attributes change</span>
<span class="hljs-keyword">function</span> <span class="function_ hljs-title">reactive</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">target, context</span>) {
    <span class="hljs-keyword">return</span> <span class="function_ hljs-title">baseReactive</span>()(<span class="function_ hljs-title">connected</span>()(target, context), context);
  };
}
</code></pre><p>And while we are at it, why not compose <em>and</em> partially apply decorators:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> {
  reactive <span class="hljs-keyword">as</span> baseReactive,
  connected,
  debounce,
} <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// Combines @reactive(), @connected() and @debounce():</span>
<span class="hljs-comment">// - reacts to attribute updates (only while the component is connected)</span>
<span class="hljs-comment">// - and runs its target method at most once per frame</span>
<span class="hljs-comment">// - and also when the component connects</span>
<span class="hljs-keyword">const</span> <span class="function_ hljs-title">reactive</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-function">(<span class="hljs-params">target, context</span>) =&gt;</span>
  <span class="function_ hljs-title">baseReactive</span>({ <span class="hljs-attr">predicate</span>: <span class="hljs-function">(<span class="hljs-params">{ isConnected }</span>) =&gt;</span> isConnected })(
    <span class="function_ hljs-title">connected</span>()(<span class="function_ hljs-title">debounce</span>({ <span class="hljs-attr">fn</span>: debounce.<span class="function_ hljs-title">raf</span>() })(target, context), context),
    context,
  );
</code></pre><p>Also remember that transformer functions return plain objects that you can modify for one-off custom transformers:</p> <pre><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { define, attr, string } <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@sirpepe/ornament&quot;</span>;

<span class="hljs-comment">// The built-in string transformer always represents strings, but we want to</span>
<span class="hljs-comment">// allow `null` in this case</span>
<span class="hljs-keyword">let</span> nullableString = {
  ...<span class="function_ hljs-title">string</span>(),
  <span class="function_ hljs-title">validate</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;undefined&quot;</span>) {
      <span class="hljs-keyword">return</span> value;
    }
    <span class="hljs-keyword">return</span> <span class="class_ hljs-title">String</span>(value);
  },
};

@<span class="function_ hljs-title">define</span>(<span class="hljs-string">&quot;my-test&quot;</span>)
<span class="hljs-keyword">class</span> <span class="class_ hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="class_ hljs-title inherited__">HTMLElement</span> {
  @<span class="function_ hljs-title">attr</span>(<span class="function_ hljs-title">nullableString</span>())
  accessor foo = <span class="hljs-string">&quot;Hello&quot;</span>;
}
</code></pre><p>Ornament&#39;s building blocks are extremely basic and you should hack, combine and extend them to get the most out of your components.</p> </main> <footer> <p>Made with markdown, <a href="https://parceljs.org/">Parcel</a> and <a href="https://highlightjs.org/">Highlight.js</a></p> </footer> </div> </body></html>